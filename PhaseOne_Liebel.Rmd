---
title: "PhaseOne_Liebel"
author: "Paige Liebel"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Phase One: Initial Data Analysis and Exploration 

# Questions for Anne to address:

Spoke with Annett: non-parametric vs parametric for each subset of data, phase 2 (ordinal mixed effects model that allows for nesting etc)

*Shapiro-Wilk Test showed parametric and sometimes non-parametric depending on the data set analyzed. For example, total overall touch frequency at the season level was normally distributed across teams, but not when we broke it down to match level. Annett said to run a test for each test and use what is appropriate for each data subset. What do you think? Previously we were set on doing only non-parametric*

Note: One limitation of this dataset is that most variables are not continuous. For example, final rank is ordinal (a team cannot finish 3.5th), and goal differential is an integer. This restricts the use of certain statistical models. We will address this further in Phase Two using an ordinal mixed-effects model framework.

# Document Run-through

1. **Season-Level Data Overview**
Data Filtering Process
Flow Chart
Total Season-Level Touches By Team

2. **Season Outcome Hypothesis**  
_Hypothesis:_ Teams with higher frequencies of pro-social touch across the season would achieve better final standings.  
_Finding:_ No strong association was observed between total pro-social touch frequency over the season and final standings (counter to prior findings in basketball). Further work could explore alternate modeling approaches (e.g., controlling for goal celebrations).
Data Management, merging, and cleaning not shown.

This led to considering a by-match analysis in relation to end-of-seaon outcome. 
-Touches per Game
-Variation of Touch Per Game within each Team
-Scaled per team analysis

3. **Outlier Analysis**

Suggested that we should take a look at how touch levels affect the outcome of individual matches.

4. **Match Outcome Hypothesis**
_Hypothesis:_ Matches where teams exceeded their typical touch behavior would be associated with better match outcomes.  
_Finding:_ A significant positive correlation was observed — matches where teams displayed higher-than-usual prosocial touch behavior were associated with more favorable goal differentials.

-Unscaled
-Scaled

5. **Type of Touch: Reciprocity**
*Does type of touch matter?*
Steps 2-4 above looked at touch frequency. This breaks the analysis down into how players are touching each other.

Similar to steps 2-4, we start with a season level outcome analysis and then go into match by match. 

_Hypothesis 1:_ Teams with a higher ratio of reciprocal vs. non-reciprocal touches finish higher in the standings.  
_Finding:_ A higher reciprocal-to-non-reciprocal touch ratio was not associated with better standings. 

_Hypothesis 1.a:_ Matches where teams have a higher ratio of reciprocal vs. non-reciprocal touches would be associated with better match outcomes.  
_Finding:_ A higher reciprocal-to-non-reciprocal touch ratio at the match-level was associated with more favorable goal differentials. 

Also looked at 'scaled' version of match-level goal differentials. 

6. **Social Network Strength**

Player Touch Concentration and Role Dynamics

_Hypothesis:_ Teams with more evenly distributed touch behaviors across players would finish higher in the end of season standings.  
_Finding:_ Teams with a more evenly shared involvement (lower Gini) tended to finish higher in the standings.

-Touch Concentration: Who Initiate and Recievers Touches (Toucher and Touchee)
-Role Dynamics: Do players act as both touchers and touchees?
-Role Ratio
-Relative Touch Contribution

7. **Time-Elapsed Touch Frequency**

Examines how Run-of-play touch frequency evolves throughout a match.

Pokes at building a possible 'causal framework'.

Compare pre-goal touch rate vs season baseline touch rate.

Asks whether touch behaviors precede scoring (suggesting touch helps create scoring opportunities) or if they are a response to scoring (suggesting celebration or momentum).

_Hypothesis:_ Teams that score the first goal of a match exhibit a higher touch rate up to that point, relative to their own baseline in matches where they did not score first.
_Finding:_  


8. **Inter-Rater Reliability**

Reliable across touch frequency, reciprocal, and non-reciprocal. 

```{r Data Management, message=FALSE, warning=FALSE, include=FALSE}
# Data_Management
# For more information on these data frames please look at the README.md file

library(tidyverse)
library(data.table)
library(broom)
library(janitor)
library(readxl)
library(rmarkdown)
library(readr)
library(ggrepel)


################################################################

# raters and corresponding sheets
# Rater1 = Paige, Rater2 = Tobi, Rater3 = Simon

raters <- list(
  Rater1 = list(touch = "Touch_Paige.csv", match = "Match_Paige.csv"),
  Rater2 = list(touch = "Touch_Tobi.csv",  match = "Match_Tobi.csv"),
  Rater3 = list(touch = "Touch_Simon.csv", match = "Match_Simon.csv")  
)

Touch_Dataframes_List <- map2(names(raters), raters, function(rater_name, files) {
  read_csv(file.path("SpreadSheets", files$touch)) %>%
    slice(-1) %>%  # remove instruction row
    mutate(across(where(is.character), ~ str_replace_all(., '^"|"$', ""))) %>%
    mutate(Rater = rater_name)
})

Touches <- bind_rows(Touch_Dataframes_List)

Match_Dataframes_List <- map2(names(raters), raters, function(rater_name, files) {
  read_csv(file.path("SpreadSheets", files$match)) %>%
    slice(-1) %>%  # removes instruction row (row 2 from the sheet)
    mutate(across(where(is.character), ~ str_replace_all(., '^"|"$', ""))) %>%
    mutate(Rater = rater_name)
})

Matches <- bind_rows(Match_Dataframes_List)


############################ Additional Data for Comparing ############################ 

#Primary_SeasonOverview <- read_csv("SpreadSheets/Primary_SeasonOverview.csv")

Team_IDs <- read_csv("SpreadSheets/TeamIDs.csv")

#Stadiums <- read_csv("SpreadSheets/Stadiums.csv")

#MatchAssignments_WatchOrder <- read_csv("SpreadSheets/MatchAssignments_WatchOrder.csv")

StandingsByWeek <- read_csv("SpreadSheets/StandingsByWeek_Clean.csv")

FinalStandings <- read_csv("SpreadSheets/FinalSeasonStandings.csv")

############################ Defining Valid Entries ############################ 

#Defining valid entries into columns based on project setup

# Define valid values

valid_touch_actions <- c(
  "Tap", "Bump", "Push", "Squeeze", "Grab",
  "Kiss", "Hug", "Rub", "Stroke"
)

valid_reciprocal <- c("N", "Y", "G")

valid_body_parts <- c(
  "H", "Arm", "FT", "Legs", "BT", "Gluteal Region", 
  "Head", "Neck", "Feet"
)

valid_situations <- c(
  "F", "FY", "FR", "KS", "SA", "PP", "SUB", "GF", "GA", "DA",
  "CK", "TI", "REF", "IT", "HB", "OFF", "GK", "HUD", "WALL",
  "PEN", "Other", "BRAWL"
)

valid_hapticrituals <- c(
  "HF1", "HF2", "LF1", "LF2", "CO", "HS", "HT", "P", "CB",
  "GHUG", "FB", "HR", "HH", "CR", "DP", "BS", "HUP", "CAP",
  "SG", "NEG", "Other", "FBP", "BBP", "HUG", "CHUG", "TA", "SHUG"
)

############################ Cleaning Data | Obvious Human Error ############################ 

#Cleaning Functions to fix user input error: Such as "Arn" to "Arm"

clean_touch_action <- function(x) {
  case_when(
    x %in% c("GHUG", "HUG") ~ "Hug",
    TRUE ~ x
  )
}

clean_reciprocal <- function(x) {
  case_when(
    x == "B" ~ "N",
    TRUE ~ x
  )
}

clean_body_parts <- function(x) {
  x %>%
    as.character() %>%
    str_remove_all('^\"|\"$') %>%           # remove any surrounding quotes
    str_split(",\\s*") %>%
    map_chr(~ paste(
      str_trim(str_replace_all(.x, c(
        "Arn" = "Arm",
        "AH" = "Arm",
        "Hand" = "H",
        "Foot" = "Feet",
        "Back Torso" = "BT",
        "Front Torso" = "FT",
        "\\bLeg\\b" = "Legs",
        "Bt" = "BT",
        "Ft" = "FT"
      ))),
      collapse = ", "
    ))
}

clean_situation <- function(x) {
  case_when(
    x == "FEF" ~ "REF",
    x == "HK" ~ "GK",
    x == "PK" ~ "PEN",
    x == "Ref" ~ "REF",
    TRUE ~ x
  )
}

clean_haptic_ritual <- function(x) {
  x %>%
    as.character() %>%
    str_remove_all('^\"|\"$') %>%
    str_split(",\\s*") %>%
    map_chr(~ paste(
      str_trim(str_replace_all(.x, c(
        "LF!" = "LF1"
      ))),
      collapse = ", "
    ))
}

clean_visibility <- function(x) {
  case_when(
    x %in% c("B", "H") ~ "G",
    TRUE ~ x
  )
}


#Now applying these functions to corresponding data frames and columns

Touches <- Touches %>%
  mutate(
    TouchAction = clean_touch_action(TouchAction),
    ToucherBodyPart = clean_body_parts(ToucherBodyPart),
    ToucheeBodyPart = clean_body_parts(ToucheeBodyPart),
    Situation = clean_situation(Situation),
    HapticRitual = clean_haptic_ritual(HapticRitual),
    Reciprocal = clean_reciprocal(Reciprocal),
    Visibility = clean_visibility(Visibility)
  )

############################ Functions to check for invalid entries in data frame ############################ 

#First fxns for checking columns that had lists (read in strangely so needed extra love)

is_invalid_bodypart <- function(x) { #splits lists within cell to look at individual values (checks to make sure "FT, Arn" is flagged for "Arn")
  x %>%
    as.character() %>%                    # ensures all input is character
    str_split(",\\s*") %>%
    map_lgl(~ {
      parts <- .x
      if (any(is.na(parts)) || any(parts == "NA")) return(TRUE)  # flag both empty and NA values
      any(!parts %in% valid_body_parts)     # TRUE only if any part is invalid
    })
}

is_invalid_haptic_ritual <- function(x) { #splits lists within cell to look at individual values (flags things like "CR, BF" for "BF" which is not a valid haptic ritual)
  x %>%
    as.character() %>%
    str_split(",\\s*") %>%
    map_lgl(~ {
      parts <- .x
      if (any(is.na(parts)) || any(parts == "NA")) return(TRUE)
      any(!parts %in% valid_hapticrituals)
    })
}

#Function to let us know where the invalid feature occurs. Output is a new column that contains the column location of the error
get_invalid_fields <- function(row) {
  invalid_fields <- c()
  
  if (!(row$Reciprocal %in% valid_reciprocal)) {
    invalid_fields <- c(invalid_fields, "Reciprocal")
  }
  
  if (is_invalid_bodypart(row$ToucherBodyPart)) {
    invalid_fields <- c(invalid_fields, "ToucherBodyPart")
  }
  
  if (is_invalid_bodypart(row$ToucheeBodyPart)) {
    invalid_fields <- c(invalid_fields, "ToucheeBodyPart")
  }
  
  if (!(row$Situation %in% valid_situations)) {
    invalid_fields <- c(invalid_fields, "Situation")
  }
  
  if (is_invalid_haptic_ritual(row$HapticRitual)) {
    invalid_fields <- c(invalid_fields, "HapticRitual")
  }
  
  if (!(row$TouchAction %in% valid_touch_actions)) {
    invalid_fields <- c(invalid_fields, "TouchAction")
  }
  
  paste(invalid_fields, collapse = ", ")
}
############################ Trouble-Shooting | Human Input Error ############################ 

#Troubleshooting: Looking at each column and checking values to look for human error while inputting data during collection

cols <- c("Team", "TouchAction", "Reciprocal", "ToucherBodyPart", "ToucheeBodyPart", "Situation", "HapticRitual", "Visibility")

#Starting with Touches

unique_vals <- Touches %>%
  select(all_of(cols)) %>% 
  map(~ unique(.))

max_len <- max(lengths(unique_vals))
padded <- map(unique_vals, ~ { length(.) <- max_len; . })
unique_values_df <- as.data.frame(padded)

#determining which touchID and rater discrepancies are connected to
#"Show me the mistakes, so I can fix them or track who made them":

Touches_invalid <- Touches %>%
  filter(
    !(Reciprocal %in% valid_reciprocal) |
      is_invalid_bodypart(ToucherBodyPart) |
      is_invalid_bodypart(ToucheeBodyPart) |
      !(Situation %in% valid_situations) |
      is_invalid_haptic_ritual(HapticRitual) |
      !(TouchAction %in% valid_touch_actions)
  )

Touches_invalid_by_rater <- split(Touches_invalid, Touches_invalid$Rater) #split by rater

Touches_invalid_labeled <- map(Touches_invalid_by_rater, function(df) { #apply get_invalid_fields() to each row in each rater's dataframe
  df %>%
    rowwise() %>%
    mutate(Invalid_Fields = get_invalid_fields(pick(everything()))) %>%
    ungroup()
})

Touches_invalid_rater1 <- Touches_invalid_labeled[["Rater1"]]
Touches_invalid_rater2 <- Touches_invalid_labeled[["Rater2"]]
Touches_invalid_rater3 <- Touches_invalid_labeled[["Rater3"]]

############################ Final Data Frame Creation | Separation of Inter-rater Game Data ############################ 

#Creating the final data frames used for analysis
#Removes the data from matches not assigned to that specific rater. For example, if Rater 1 was assigned match 126, 
#then Rater 2 and 3 also watched it and have populated data for that match.
#this section removes that data created from rater 2 and 3 keeping only rater 1s info.
#Do this to both the Matches and Touches Dataframs (has to happen twice)

#Define match assignments
InterRaterMatches_Rater1 <- c("127", "115", "26", "87") #Paige
InterRaterMatches_Rater2 <- c("114", "39", "163", "42") #Tobi
InterRaterMatches_Rater3 <- c("95", "150", "38", "160") #Simon

#Combine all 12 interrater matches with rater mapping
interrater_assignments <- tibble(
  SeasonMatchNumber = c(InterRaterMatches_Rater1, InterRaterMatches_Rater2, InterRaterMatches_Rater3),
  AssignedRater = c(rep("Rater1", length(InterRaterMatches_Rater1)),
                    rep("Rater2", length(InterRaterMatches_Rater2)),
                    rep("Rater3", length(InterRaterMatches_Rater3)))
)

#SeasonMatchNumber imported differently, need to change to same character thingy
interrater_assignments <- interrater_assignments %>%
  mutate(SeasonMatchNumber = as.character(SeasonMatchNumber))

Touches <- Touches %>%
  mutate(SeasonMatchNumber = str_remove(as.character(SeasonMatchNumber), "^0+")) #removes leading zeros

Matches <- Matches %>%
  mutate(SeasonMatchNumber = str_remove(as.character(SeasonMatchNumber), "^0+")) #removes leading zeros

#make new data frame from Touches, if row contains InterRaterMatches_Rater1 and the word rater 1, keep it, otherwise delete row

Touches_final <- Touches %>% #This df has all matches, but excludes the repeated matches watched for inter-rater study except by the rater they were originally assigned for
  anti_join(interrater_assignments, by = c("SeasonMatchNumber" = "SeasonMatchNumber")) %>%
  bind_rows(
    Touches %>%
      inner_join(interrater_assignments, by = c("SeasonMatchNumber")) %>%
      filter(Rater == AssignedRater)
  )

#Same as above but for matches now (performance data for each match)
Matches_final <- Matches %>%
  anti_join(interrater_assignments, by = c("SeasonMatchNumber" = "SeasonMatchNumber")) %>%
  bind_rows(
    Matches %>%
      inner_join(interrater_assignments, by = c("SeasonMatchNumber")) %>%
      filter(Rater == AssignedRater)
  )


############################ Inter-rater Game Data ############################ 

#Creation of data frames for Inter-rater data analysis
#Simply looks at all matches that were watched by multiple people

Touches_interrater <- Touches %>%
  inner_join(interrater_assignments, by = "SeasonMatchNumber")

Matches_interrater <- Matches %>%
  inner_join(interrater_assignments, by = "SeasonMatchNumber")


```

```{r Matches_Performance, message=FALSE, warning=FALSE, include=FALSE}
#Cleaning up and Extracting Info from the Match_Performance Sheet
#Goal to get:
#Minutes Played for each player
#Minutes played by each team
#Penalty Kick Info

library(tidyverse)
library(data.table)
library(broom)
library(janitor)
library(readxl)
library(rmarkdown)
library(readr)
library (dplyr)
library(plotly)
library(mgcv)
library(ggplot2)
library(forcats)
library(ggridges)
library(DescTools)
library(tidyr)
library(purrr)

############################ Overall Team Data ############################
#Info Team by Team
Matches_ID <- Matches_final %>%
  mutate(
    MatchID = str_pad(MatchID, width = 4, pad = "0"),  # in case it was shortened
    TeamID = str_sub(MatchID, 1, 2),
    Substitutes = as.character(Substitutes),
    Substitutes = str_replace_all(Substitutes, "\\.", ",")
  )

team_minutesplayed <- Matches_ID %>% 
  mutate(
    MatchLength = as.numeric(MatchLength)  # Convert to numeric
  ) %>%
  group_by(TeamID) %>%
    summarise(
      TotalMinutesPlayed = sum(MatchLength, na.rm = TRUE),
      MatchCount = n()
    ) %>%
    arrange(desc(TotalMinutesPlayed))

#Formations teams played
formation_counts <- Matches_ID %>%
  group_by(TeamID, Formation) %>%
  summarise(FormationCount = n(), .groups = "drop") %>%
  pivot_wider(
    names_from = Formation,
    values_from = FormationCount,
    values_fill = 0  # Fill in 0 if a team never used a certain formation
  )

############################ Overall League Data ############################

#Most Popular Formations
popular_formations <- Matches_ID %>%
  group_by(Formation) %>%
  summarise(TimesUsed = n(), .groups = "drop") %>%
  arrange(desc(TimesUsed))

############################ Player Data ############################

#Determine how many minutes each player played

#First determine the starters across the season for each team
starter_players <- Matches_ID %>%
  mutate(StarterList = str_split(Starters, ",\\s*")) %>%   # split by comma, trim spaces
  rowwise() %>%
  mutate(
    StarterCount = length(StarterList),
    StarterFlag = ifelse(StarterCount != 11, TRUE, FALSE)  # flag if not 11
  ) %>%
  ungroup() %>%
  select(TeamID, StarterList, StarterFlag, SeasonMatchNumber, FirstHalfLength, SecondHalfLength) %>%
  unnest(StarterList) %>%
  mutate(StarterList = str_trim(StarterList))  # clean whitespace

unique_team_players <- starter_players %>%
  mutate(StarterList = str_trim(StarterList)) %>%
  distinct(TeamID, StarterList) %>%
  rename(Player = StarterList)

flagged_starter_matches <- Matches_ID %>%
  mutate(
    StarterList = str_split(Starters, ",\\s*"),
    StarterCount = lengths(StarterList)
  ) %>%
  filter(StarterCount != 11) %>%
  select(SeasonMatchNumber, FirstHalfLength, SecondHalfLength, TeamID, StarterCount, Starters)

#Determine the Subs and add them to the starters
subs_exploded <- Matches_ID %>%
  select(SeasonMatchNumber, FirstHalfLength, SecondHalfLength, TeamID, Substitutes) %>%
  filter(!is.na(Substitutes) & Substitutes != "") %>%
  mutate(Substitutes = as.character(Substitutes)) %>% 
  mutate(
    Substitutes = str_split(Substitutes, ",\\s*")) %>%
  unnest(Substitutes)

#Parse the substitution strings into their parts
subs_parsed_noRedCards <- subs_exploded %>%
  filter(str_detect(Substitutes, "^\\d{8}$")) %>%  # Keep only well-formed subs
  mutate(
    SubIn   = str_sub(Substitutes, 1, 2),
    SubOut  = str_sub(Substitutes, 3, 4),
    Half    = str_sub(Substitutes, 5, 5),
    Minute  = as.numeric(str_sub(Substitutes, 6, 8))
  ) %>%
  select(SeasonMatchNumber, FirstHalfLength, SecondHalfLength, TeamID, Substitutes, SubIn, SubOut, Half, Minute)

# Parse red card "subs"
red_cards_parsed <- subs_exploded %>%
  filter(str_detect(Substitutes, "^FR\\d{6}$")) %>%
  mutate(
    SubIn   = NA_character_,  # no one comes in because of Red Card
    SubOut  = str_sub(Substitutes, 3, 4),  # player sent off
    Half    = str_sub(Substitutes, 5, 5),
    Minute  = as.numeric(str_sub(Substitutes, 6, 8))
  ) %>%
  select(SeasonMatchNumber, FirstHalfLength, SecondHalfLength, TeamID, Substitutes, SubIn, SubOut, Half, Minute)

subs_parsed <- bind_rows(subs_parsed_noRedCards, red_cards_parsed) #combines together acceptable values

#Sub issues to flag
sub_issues <- Matches_ID %>%
  mutate(SeasonMatchNumber = as.character(SeasonMatchNumber)) %>%
  separate_rows(Substitutes, sep = ",\\s*") %>%
  filter(Substitutes != "") %>%
  mutate(Flag = !str_detect(Substitutes, "^\\d{8}$") & !str_detect(Substitutes, "^FR\\d{6}$")) %>% #selects subs with 8 digits and those with improper FR setup
  filter(Flag) %>%
  select(SeasonMatchNumber, Substitutes)

# Now filter out bad sub entries (those not 8 digits or not FR + 6 digits)
subs_parsed_clean <- subs_parsed %>%
  anti_join(sub_issues, by = c("SeasonMatchNumber", "Substitutes"))

# Get all distinct subbed-in players per team
subbed_in_players <- subs_parsed_clean %>%
  select(TeamID, SubIn) %>%
  distinct() %>%
  rename(Player = SubIn)

unique_sub_players <- subs_parsed_clean %>%
  mutate(SubIn = str_trim(SubIn)) %>%                 # <- trim here too
  distinct(TeamID, SubIn) %>%
  rename(Player = SubIn)

# Combine starters and subbed-in players
all_unique_team_players <- bind_rows(unique_team_players, unique_sub_players) %>%
  mutate(
    Player = str_trim(Player),
    PlayerCharLength = nchar(Player)
  ) %>%
  distinct(TeamID, Player, PlayerCharLength)

#Give a complete list of each jersey number that shows up for a team
# Group players by team and nest them into a list column
team_player_lists <- all_unique_team_players %>%
  mutate(Player = as.character(str_trim(Player))) %>%  # Clean and ensure characters
  group_by(TeamID) %>%
  summarise(
    PlayerList = paste(sort(unique(Player)), collapse = ", "),
    .groups = "drop"
  )

#Now Let's figure out minutes played for starters who were not subbed out in a match

# From starter_players: select and rename StarterList to Player
starter_players_long <- starter_players %>%
  select(SeasonMatchNumber, TeamID, StarterList) %>%
  rename(Player = StarterList)

# From subs_parsed_clean: select and rename SubIn to Player
subins_long <- subs_parsed_clean %>%
  select(SeasonMatchNumber, TeamID, SubIn) %>%
  rename(Player = SubIn)

# Combine both into one dataframe, keep distinct values
match_player_entries <- bind_rows(starter_players_long, subins_long) %>%
  mutate(Player = str_trim(as.character(Player))) %>%
  distinct(SeasonMatchNumber, TeamID, Player, .keep_all = TRUE)

#pure iteration row by row (inefficient) to see fi player was subbed in/out
match_player_entries <- match_player_entries %>% 
  mutate(
    WasPlayerSubbedIn = pmap_chr(
      list(SeasonMatchNumber, TeamID, Player),
      ~ if_else(
        any(subs_parsed_clean$SeasonMatchNumber == ..1 &
              subs_parsed_clean$TeamID == ..2 &
              subs_parsed_clean$SubIn == ..3),
        "Y", "N"
      )
    )
  )

match_player_entries <- match_player_entries %>%
  mutate(
    WasPlayerSubbedOut = pmap_chr(
      list(SeasonMatchNumber, TeamID, Player),
      ~ if_else(
        any(subs_parsed_clean$SeasonMatchNumber == ..1 &
              subs_parsed_clean$TeamID == ..2 &
              subs_parsed_clean$SubOut == ..3),
        "Y", "N"
      )
    )
  )

Matches_ID_unique <- Matches_ID %>%
  mutate(SeasonMatchNumber = as.character(SeasonMatchNumber)) %>%
  select(SeasonMatchNumber, TeamID, FirstHalfLength, SecondHalfLength) %>%
  distinct()

Matches_ID_unique %>%
  count(SeasonMatchNumber, TeamID) %>%
  filter(n > 1)  # should not happen

Matches_ID_unique <- Matches_ID_unique %>% distinct(SeasonMatchNumber, TeamID, .keep_all = TRUE)

# Now join safely by both SeasonMatchNumber and TeamID
match_player_entries <- match_player_entries %>%
  mutate(SeasonMatchNumber = as.character(SeasonMatchNumber)) %>%
  left_join(Matches_ID_unique, by = c("SeasonMatchNumber", "TeamID"))

# First, extract only relevant sub-in/out info
sub_in_info <- subs_parsed_clean %>%
  filter(!is.na(SubIn)) %>%  # red cards won't have SubIn
  select(SeasonMatchNumber, TeamID, Player = SubIn, SubbedInHalf = Half, SubbedInMinute = Minute)
  
sub_out_info <- subs_parsed_clean %>%
  select(SeasonMatchNumber, TeamID, Player = SubOut, SubbedOutHalf = Half, SubbedOutMinute = Minute)
  
sub_in_info %>%
  count(SeasonMatchNumber, TeamID, Player) %>%
  filter(n > 1)  # should all be 1

sub_out_info %>%
  count(SeasonMatchNumber, TeamID, Player) %>%
  filter(n > 1)  # same

# Now, join it to match_player_metrics for only those who were subbed in/out
match_player_entries <- match_player_entries %>%
  left_join(sub_in_info, by = c("SeasonMatchNumber", "TeamID", "Player"))

match_player_entries <- match_player_entries %>%
  left_join(sub_out_info, by = c("SeasonMatchNumber", "TeamID", "Player"))

match_player_entries <- match_player_entries %>%
  mutate(
    Player = str_trim(as.character(Player)),
    TeamID = str_trim(as.character(TeamID)),
    SeasonMatchNumber = str_trim(as.character(SeasonMatchNumber))
  )

#create a function to turn everything into seconds
convert_mmss_to_seconds <- function(mmss) {
  mm <- floor(mmss / 100)
  ss <- mmss %% 100
  mm * 60 + ss
}

#Convert everything to numeric
match_player_entries <- match_player_entries %>%
  mutate(
    FirstHalfLength = as.numeric(FirstHalfLength),
    SecondHalfLength = as.numeric(SecondHalfLength),
    SubbedInMinute = as.numeric(SubbedInMinute),
    SubbedOutMinute = as.numeric(SubbedOutMinute)
  )

# Apply to your data frame
match_player_entries <- match_player_entries %>%
  mutate(
    FirstHalfSeconds = convert_mmss_to_seconds(FirstHalfLength),
    SecondHalfSeconds = convert_mmss_to_seconds(SecondHalfLength)
  )

#Let's do math to figure out how many seconds each player played
match_player_entries <- match_player_entries %>%
  mutate(
    SubInOutConflict = if_else(
      WasPlayerSubbedIn == "Y" & WasPlayerSubbedOut == "Y",
      TRUE, FALSE
    )
  ) %>% 
  mutate(
    MatchSecondsPlayed = case_when(
      # Not subbed in and not subbed out → full match
      WasPlayerSubbedIn == "N" & WasPlayerSubbedOut == "N" ~ (FirstHalfSeconds + SecondHalfSeconds),
      
      # Not subbed in and subbed out in 1st half
      WasPlayerSubbedIn == "N" & WasPlayerSubbedOut == "Y" & SubbedOutHalf == "1" ~
        if_else(SubbedOutMinute == 46, FirstHalfSeconds, (SubbedOutMinute * 60)),
      
      # Not subbed in and subbed out in 2nd half
      WasPlayerSubbedIn == "N" & WasPlayerSubbedOut == "Y" & SubbedOutHalf == "2" ~
        if_else(SubbedOutMinute == 46,
                FirstHalfSeconds,
                (FirstHalfSeconds + ((SubbedOutMinute - 45)*60))),
      
      # Subbed in and subbed in 1st half
      WasPlayerSubbedIn == "Y" & WasPlayerSubbedOut == "N" & SubbedInHalf == "1" ~
        if_else(SubbedInMinute == 46, convert_mmss_to_seconds(SecondHalfLength), 
                (SecondHalfSeconds + (FirstHalfSeconds - (SubbedInMinute*60)))),
      
      # Subbed in and subbed in 2nd half
      WasPlayerSubbedIn == "Y" & WasPlayerSubbedOut == "N" & SubbedInHalf == "2" ~
        if_else(SubbedInMinute == 46, SecondHalfSeconds, 
                (SecondHalfSeconds - ((SubbedInMinute - 45)*60))),
      
      # Subbed in AND subbed out
      WasPlayerSubbedIn == "Y" & WasPlayerSubbedOut == "Y" ~
        case_when(
          SubbedInMinute == 46 ~ (SubbedOutMinute - 45) * 60,
          
          SubbedInHalf == "1" & SubbedOutHalf == "1" ~ 
            (SubbedOutMinute - SubbedInMinute) * 60,
          
          SubbedInHalf == "1" & SubbedOutHalf == "2" ~ 
            (FirstHalfSeconds - SubbedInMinute * 60) + (SubbedOutMinute - 45) * 60,
          
          SubbedInHalf == "2" & SubbedOutHalf == "2" ~ 
            (SubbedOutMinute - SubbedInMinute) * 60,
          
          TRUE ~ NA_real_
        ),
      
      # Fallback
      TRUE ~ NA_real_
    )
  )

#Add a column with Rater so we know who is having errors
match_player_entries <- match_player_entries %>%
  left_join(
    Matches_final %>%
      select(SeasonMatchNumber, Rater) %>%
      distinct(),  # <-- ensures only one row per SeasonMatchNumber-Rater pair
    by = "SeasonMatchNumber"
  )

match_player_entries <- match_player_entries %>%
  mutate(
    SubInTime = case_when(
      WasPlayerSubbedIn == "N" ~ 0,
      WasPlayerSubbedIn == "Y" & SubbedInHalf == "1" ~ SubbedInMinute * 60,
      WasPlayerSubbedIn == "Y" & SubbedInHalf == "2" ~ (FirstHalfSeconds + ((SubbedInMinute - 45) * 60)),
      TRUE ~ NA_real_
    )
  )

#Now I have seconds played. Add that up for each player over the season.
player_season_totals <- match_player_entries %>%
  group_by(TeamID, Player) %>%
  summarise(
    TotalSecondsPlayed = sum(MatchSecondsPlayed, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(TotalSecondsPlayed))


duplicates <- match_player_entries %>%
  group_by(SeasonMatchNumber, TeamID, Player) %>%
  filter(n() > 1) %>%
  arrange(SeasonMatchNumber, TeamID, Player)


checker <- match_player_entries %>%
  count(SeasonMatchNumber, TeamID, Player) %>%
  filter(n > 1) %>%
  arrange(desc(n))

```


## Overview Summary and Touch Data Filtering

In this section, we summarize the raw touch dataset and walk through the filtering process that created the dataset used for hypothesis testing. 
This includes defining what counts as a prosocial touch, removing non-gameflow situations like goals and substitutions, and labeling touches as reciprocal or nonreciprocal.

```{r Overview_Summary, echo=TRUE, message=FALSE, warning=FALSE}
# Data Summary and Overview
# Gives Simple overall counts, tables, data make-up etc

library(tidyverse)
library(data.table)
library(broom)
library(janitor)
library(readxl)
library(rmarkdown)
library(readr)
library (dplyr)
library(knitr)
library(ggridges)
library(tibble)

############################ Complete data summary | No filtering ############################ 

#Create Tables that summarizes complete data of "Touches_final" and "Matches_final"

Touches_Summary <- Touches_final
Matches_Summary <- Matches_final

Total_Touch_Instance_count <- nrow(Touches_Summary) #count total number of touches recorded

Total_Match_Count <- n_distinct(Touches_Summary$SeasonMatchNumber) #total number of matches watched

Total_Teams <- n_distinct(Touches_Summary$Team) #teams recorded

Total_Matches_perTeam <- 26 #Matches each team played (verified below)

Summary_Table_A <- tibble(
  Variable = c("Total_Touch_Instance_count", "Total_Match_Count", "Total_Teams", "Total_Matches_perTeam"),
  Value = c(
    nrow(Touches_Summary),
    n_distinct(Touches_Summary$SeasonMatchNumber),
    n_distinct(Touches_Summary$Team),
    26  # Manually verified
  )
)

############################ FlowChart | Filtering ############################ 

# Prosocial vs Nonsocial

# Prosocial touches are defined as all haptic rituals recorded excluding: 
# Tactical Adjustments, Collisions, and Negative Touch
Exclude_Touch <- c("TA", "CO", "NEG")

#Only Prosocial Touches
Touches_ProSocial <- Touches_final %>%
  filter(!(HapticRitual %in% Exclude_Touch))

#Non-social touches table (only those in Exclude_Touch)
Touches_NonSocial <- Touches_final %>%
  filter(HapticRitual %in% Exclude_Touch)

# Count n for social and nonsocial:
social_count <- nrow(Touches_ProSocial)
nonsocial_count <- nrow(Touches_NonSocial)

#Excluding goal for/against, substitutions (starting with prosocial set)
Exclude_Situation <- c("GF", "GA", "SUB") 

#Only Prosocial Touches
Touches_CoreData <- Touches_ProSocial %>%
  filter(!(Situation %in% Exclude_Situation))

#Count for other GF/GA/SUB
Touches_GoalsSubs <- Touches_ProSocial %>%
  filter(Situation %in% Exclude_Situation)

# Count n for GF,GA,SUB and Run-of-play:
coredata_count <- nrow(Touches_CoreData)
GoalsSubs_count <- nrow(Touches_GoalsSubs)

#Look at Reciprocity
Touches_ReciprocalNonRecip <- Touches_ProSocial %>% 
  mutate(
    Reciprocity = str_trim(Reciprocal) #cleans up white spaces in case
  )

#Define Reciprocity
Touches_ReciprocalNonRecip <- Touches_ReciprocalNonRecip %>%
  filter(!(Situation %in% Exclude_Situation)) %>%   # exclude GF, GA, SUB situations
  mutate(
    Reciprocity_Group = case_when(
      Reciprocity %in% c("Y", "G") ~ "Reciprocal",
      Reciprocity == "N" ~ "NonReciprocal",
      TRUE ~ "Other"   # just in case of other values
    )
  )

# Reciprocal touches table
Reciprocal_Touches <- Touches_ReciprocalNonRecip %>%
  filter(Reciprocity_Group == "Reciprocal")

# Nonreciprocal touches table
NonReciprocal_Touches <- Touches_ReciprocalNonRecip %>%
  filter(Reciprocity_Group == "NonReciprocal")

# Counts
reciprocal_count <- nrow(Reciprocal_Touches)
nonreciprocal_count <- nrow(NonReciprocal_Touches)

#Create a table for all of this: 

# Summary Table
touch_summary_fowchart <- tibble(
  Step = c(
    "Total Touches",
    "Prosocial Touches",
    "NonSocial Touches",
    "Prosocial: Run of Play",
    "Prosocial: Goals For, Goals Against, Sub",
    "Prosocial & Run of Play: Reciprocal",
    "Prosocial & Run of Play: NonReciprocal"
  ),
  Count = c(
    nrow(Touches_final),
    social_count,
    nonsocial_count,
    coredata_count,
    GoalsSubs_count,
    reciprocal_count,
    nonreciprocal_count
  )
)

############### Touches Per Team (Season) #####################

#Cleans up Team Name mispellings
Matches_Summary <- Matches_Summary %>%
  mutate(TeamName = case_when(
    TeamName %in% c("Racing Louisville", "Racing louisville FC", "Louisville Racing") ~ "Racing Louisville FC",
    TeamName %in% c("NC Courage", "Carolina Courage") ~ "North Carolina Courage",
    TeamName %in% c("KC Current") ~ "Kansas City Current",
    TeamName %in% c("Chicago Redstar FC") ~ "Chicago Red Stars",
    TeamName %in% c("Portland Thorns") ~ "Portland Thorns FC",
    TeamName %in% c("Gotham FC") ~ "NJ/NY Gotham FC",
    TeamName %in% c("San Diego Wave") ~ "San Diego Wave FC",
    TeamName %in% c("Seattle Reign") ~ "Seattle Reign FC",
    TRUE ~ TeamName
  ))

TeamMatchCounts <- Matches_Summary %>%
  count(TeamName, name = "MatchesPlayed")

TeamMatchCounts <- TeamMatchCounts %>%
  left_join(Team_IDs, 
            by = c("TeamName" = "Team Name 2024 Season"))

ByTeam_Total_Touch_Instance_count <- Touches_CoreData %>% 
  count(Team, name = "Total Season Touches") %>% 
  rename(TeamID = Team)

TeamMatchCounts <- TeamMatchCounts %>%
  left_join(ByTeam_Total_Touch_Instance_count, 
            by = c("TeamID" = "TeamID"))

######################## Total Season #######################################
Matches_Summary <- Matches_Summary %>%
  mutate(TeamName = case_when(
    TeamName %in% c("Racing Louisville", "Racing louisville FC", "Louisville Racing") ~ "Racing Louisville FC",
    TeamName %in% c("NC Courage", "Carolina Courage") ~ "North Carolina Courage",
    TeamName %in% c("KC Current") ~ "Kansas City Current",
    TeamName %in% c("Chicago Redstar FC") ~ "Chicago Red Stars",
    TeamName %in% c("Portland Thorns") ~ "Portland Thorns FC",
    TeamName %in% c("Gotham FC") ~ "NJ/NY Gotham FC",
    TeamName %in% c("San Diego Wave") ~ "San Diego Wave FC",
    TeamName %in% c("Seattle Reign") ~ "Seattle Reign FC",
    TRUE ~ TeamName
  ))

TeamMatchCounts <- Matches_Summary %>%
  count(TeamName, name = "MatchesPlayed")

TeamMatchCounts <- TeamMatchCounts %>%
  left_join(Team_IDs, 
            by = c("TeamName" = "Team Name 2024 Season"))

# Total, Unfiltered, data 
ByTeam_Total_Touch_Instance_Unfiltered <- Touches_Summary %>% 
  count(Team, name = "Total Season Touches") %>% 
  rename(TeamID = Team)

TeamMatchCounts_Unfiltered <- TeamMatchCounts %>%
  left_join(ByTeam_Total_Touch_Instance_Unfiltered, 
            by = c("TeamID" = "TeamID"))

unfiltered <- TeamMatchCounts_Unfiltered %>%
  mutate(Median = median(`Total Season Touches`, na.rm = TRUE),
         AboveMedian = `Total Season Touches` > Median)

unfiltered <- unfiltered %>%
  arrange(`Total Season Touches`) %>%
  mutate(TeamID = factor(TeamID, levels = TeamID))  # preserve the new order

unfiltered_graph <- ggplot(unfiltered, aes(x = TeamID, y = `Total Season Touches`)) +
  geom_col(fill = "gray60") +
  labs(
    title = "Total Season Touches by Team",
    subtitle = "Unfiltered, All Recorded Touch Instances (n = 14869)",
    x = "Team (Ordered by Touch Frequency)",
    y = "Touch Frequency"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


unfiltered_densityplot <- ggplot(unfiltered, aes(x = `Total Season Touches`)) +
  geom_density(fill = "gray60", alpha = 0.7) +
  geom_vline(xintercept = median(unfiltered$`Total Season Touches`, na.rm = TRUE),
             linetype = "dashed", color = "black") +
  labs(title = "Density of Total Season Touches by Team (Unfiltered)",
       x = "Total Season Touches",
       y = "Density") +
  theme_minimal()


# Filtered for Touches_CoreData (Prosocial and run of play Touches by team)
ByTeam_Total_Touch_Instance_count <- Touches_CoreData %>% 
  count(Team, name = "Total Season Touches") %>% 
  rename(TeamID = Team)

TeamMatchCounts <- TeamMatchCounts %>%
  left_join(ByTeam_Total_Touch_Instance_count, 
            by = c("TeamID" = "TeamID"))

filtered <- ByTeam_Total_Touch_Instance_count %>%
  arrange(`Total Season Touches`) %>%
  mutate(TeamID = factor(TeamID, levels = TeamID))

filtered_plot <- ggplot(filtered, aes(x = TeamID, y = `Total Season Touches`)) +
  geom_col(fill = "gray60") +
  labs(title = "Total Season Touches by Team",
       subtitle = "Filtered to Core Data: Run-of-Play (n = 7955)",
       x = "Team (Ordered by Touch Count)",
       y = "Total Season Touches") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


filtered_densityplot <- ggplot(filtered, aes(x = `Total Season Touches`)) +
  geom_density(fill = "gray60", alpha = 0.7) +
  labs(title = "Density of Total Season Touches by Team (Filtered: Core Data)",
       x = "Total Season Touches",
       y = "Density") +
  theme_minimal()

# Check if filtered data is parametric:

totalseason_parametric <- shapiro.test(filtered$`Total Season Touches`)

# Data is normal! Therefore, parametric.

#Boxplot with both
touch_box_df <- bind_rows(
  unfiltered %>%
    mutate(Type = "All-Recorded (n=14869)") %>%
    select(Type, `Total Season Touches`),
  
  filtered %>%
    mutate(Type = "Filtered to Run-of-Play (n=7955)") %>%
    select(Type, `Total Season Touches`)
) %>%
  mutate(Type = factor(Type, levels = c("All-Recorded (n=14869)", "Filtered to Run-of-Play (n=7955)")))


totalseason_boxplot <- ggplot(touch_box_df, aes(x = Type, y = `Total Season Touches`)) +
  geom_boxplot(fill = "gray70", outlier.shape = NA) +
  geom_jitter(width = 0.2, height = 0, size = 2, color = "gray30", alpha = 0.8) +
  labs(title = "Comparison of Total Season Touch Data Subsets",
       x = "Data Subset",
       y = "Total Season Touch Frequency by Team") +
  theme_minimal()

#Fantastic.

############### Touches Per Match | Breakdown by Match #############################

#First just Histogram of touch frequency per match across all teams

# Count touches per team per game from CoreHyp data frame
Touches_per_match <- Touches_CoreData %>%
  group_by(Team, SeasonMatchNumber) %>%
  summarise(TouchCount = n(), .groups = "drop")

touches_permatch_plot <- ggplot(Touches_per_match, aes(x = TouchCount)) +
  geom_histogram(binwidth = 5, fill = "gray60", color = "white") +
  labs(
    title = "Distribution of Touches per Game Across All Teams",
    x = "Touches Per Game",
    y = "Number of Matches"
  ) +
  theme_minimal()

#Check normalacy

touches_per_match_parametric <- shapiro.test(Touches_per_match$TouchCount)

#NON-PARAMETIC! Do not use linear regression etc. use non-parametric alternatives.

#By team explosion of histograms
FinalStandings <- FinalStandings %>%
  mutate(TeamID = str_pad(as.character(TeamID), width = 2, pad = "0"))

Touches_per_match_team <- Touches_per_match %>%
  left_join(FinalStandings %>% select(TeamID, Team), 
            by = c("Team" = "TeamID")) %>%
  mutate(TeamLabel = paste0("Team ID : ", Team))

touches_permatch_plot_teamlevel <- ggplot(Touches_per_match_team, aes(x = TouchCount)) +
  geom_histogram(binwidth = 5, fill = "gray60", color = "white") +
  facet_wrap(~ TeamLabel, scales = "fixed") +
  scale_y_continuous(
    limits = c(0, 10),
    breaks = c(0, 5, 10)  # Only these tick marks shown
  ) +
  labs(
    title = "Touches Per Game by Team (each team played 26 matches)",
    x = "Touches Per Game",
    y = "Number of Matches"
  ) +
  theme_minimal() +
  theme(strip.text = element_text(size = 10))

#Ridgeline Plot
#Stacked Density plot for each team
#height of curve is relative frequency of touch

touch_permatch_ridgelineplot <- ggplot(Touches_per_match, aes(x = TouchCount, y = reorder(Team, TouchCount, median), fill = Team)) +
  geom_density_ridges(scale = 2, alpha = 0.8, color = "white") +
  labs(
    title = "Touches per Game Distribution by Team",
    x = "Touches per Game",
    y = "Team (Sorted by Median Touches)"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

Touches_per_game_ranked <- Touches_per_match %>%
  left_join(FinalStandings %>% select(TeamID, Rank), by = c("Team" = "TeamID")) %>%
  arrange(Rank) %>%
  mutate(Rank = as.numeric(Rank))

#Same thing but ordered by final rank
# Visualize with boxplots 
TouchesPerGame_vs_rank <- ggplot(Touches_per_game_ranked, aes(x = Rank, y = TouchCount, group = Rank)) +
  geom_boxplot(fill = "lightblue", color = "black") +
  scale_x_reverse(breaks = 1:14) +  # clean 1–14 axis
  labs(
    title = "Variation of Within-Team Touch Frequency per Game",
    x = "Team (Ordered by Final Rank)",
    y = "Touches per Game"
  ) +
  theme_minimal()

############### Scaling by team #####################################

# recognizing each team has their own touch culture

#Scaled touch = (touchCount - MedianTouch of team) / IQR of team

Touches_per_match_scaled <- Touches_per_match %>%
  group_by(Team) %>%
  mutate(
    median_touch = median(TouchCount, na.rm = TRUE),
    iqr_touch = IQR(TouchCount, na.rm = TRUE),
    ScaledTouch = (TouchCount - median_touch) / iqr_touch
  ) %>%
  ungroup()

Touches_per_match_scaled_ranked <- Touches_per_match_scaled %>%
  left_join(FinalStandings %>% select(TeamID, Rank), by = c("Team" = "TeamID")) %>%
  mutate(
    Rank = as.numeric(Rank),
    Team = factor(Team, levels = FinalStandings$TeamID[order(FinalStandings$Rank)])
  )

touches_permatch_scaled_plot <- ggplot(Touches_per_match_scaled_ranked, aes(x = Team, y = ScaledTouch, group = Team)) +
  geom_boxplot(fill = "lightblue", color = "black") +
  scale_x_discrete(labels = FinalStandings$TeamID[order(FinalStandings$Rank)]) +  # Optional: show TeamIDs on x-axis
  labs(
    title = "Variation of Scaled Touches per Match by Team (Ordered by Final Rank)",
    x = "Team (Ordered by Final Rank)",
    y = "Scaled Touches (Centered and Scaled by IQR)"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


############### Outliers #####################################

# Check distribution and identify potential outlier

#outlier is 1.5 IQR

Touches_per_match_outliers <- Touches_per_match %>%
  group_by(Team) %>%
  mutate(
    Q1 = quantile(TouchCount, 0.25, na.rm = TRUE),
    Q3 = quantile(TouchCount, 0.75, na.rm = TRUE),
    IQR_val = Q3 - Q1,
    lower_fence = Q1 - 1.5 * IQR_val,
    upper_fence = Q3 + 1.5 * IQR_val,
    OutlierStatus = if_else(TouchCount < lower_fence | TouchCount > upper_fence, "Outlier", "Normal")
  ) %>%
  ungroup()

# Extract TeamID from MatchID in Matches_final
Matches_for_outliers <- Matches_final %>%
  mutate(Team = str_sub(MatchID, 1, 2))  # first two characters as TeamID

# Make sure Team codes are padded the same way
Touches_per_match_outliers <- Touches_per_match_outliers %>%
  mutate(Team = str_pad(as.character(Team), width = 2, pad = "0"))

Matches_for_outliers <- Matches_for_outliers %>%
  mutate(Team = str_pad(as.character(Team), width = 2, pad = "0"))

# Now join using SeasonMatchNumber and Team
Touches_per_match_outliers <- Touches_per_match_outliers %>%
  left_join(Matches_for_outliers %>% select(SeasonMatchNumber, Team, Outcome, GoalsFor),
            by = c("SeasonMatchNumber", "Team"))

outcome_summary <- Touches_per_match_outliers %>%
  group_by(OutlierStatus, Outcome) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(OutlierStatus) %>%
  mutate(proportion = count / sum(count))

match_outcomes_outliers <- ggplot(outcome_summary, aes(x = OutlierStatus, y = proportion, fill = Outcome)) +
  geom_col(position = "dodge") +
  geom_text(aes(label = count), position = position_dodge(0.9), vjust = -0.25) +
  labs(
    title = "Match Outcomes by Outlier Status",
    x = "Match Type",
    y = "Proportion (Note that Outliers have n = 9"
  ) +
  theme_minimal()

table_outcomes <- table(Touches_per_match_outliers$OutlierStatus, Touches_per_match_outliers$Outcome)

# Create the summary table of counts by OutlierStatus and Outcome
outcome_summary_table <- Touches_per_match_outliers %>%
  group_by(OutlierStatus, Outcome) %>%
  summarise(Count = n(), .groups = "drop") %>%
  tidyr::pivot_wider(names_from = Outcome, values_from = Count, values_fill = 0)


fisher_res <- fisher.test(table_outcomes)

#Extreme touch events seem to propose a different match outcome. Dive into match level analysis.


#### Clean up the Matches sheet a bit more:

#Clean Match column data for use
Matches_final_cleaned <- Matches_final %>%
  mutate(
    GoalsFor = as.numeric(str_trim(GoalsFor)),
    GoalsAgainst = as.numeric(str_trim(GoalsAgainst))
  )


# Turn any X or XX in Goals For to 0
Matches_final_cleaned <- Matches_final %>%
  mutate(
    GoalsFor = case_when(
      GoalsFor %in% c("X", "XX") ~ "0",
      TRUE ~ GoalsFor
    ),
    GoalsFor = as.numeric(str_trim(GoalsFor)),
    GoalsAgainst = case_when(
      GoalsAgainst %in% c("X", "XX") ~ "0",
      TRUE ~ GoalsAgainst
    ),
    GoalsAgainst = as.numeric(str_trim(GoalsAgainst))
  )


#Get TeamID into Matches_final
Matches_finalID <- Matches_final_cleaned %>%
  mutate(
    MatchID = str_pad(MatchID, width = 4, pad = "0"),  # in case it was shortened
    TeamID = str_sub(MatchID, 1, 2),                     # preserve leading zeros
    GoalDiff = GoalsFor - GoalsAgainst
  )
```

Code for core hypothesis (discussed further at a later point)
```{r CoreHypothesis, echo=TRUE, message=FALSE, warning=FALSE}
# Core_Hypothesis
# For more information on these data frames please look at the README.md file

library(tidyverse)
library(data.table)
library(broom)
library(janitor)
library(readxl)
library(rmarkdown)
library(readr)
library (dplyr)

############################ Create Data Set for this Hypothesis ############################ 

#Count of frequency of touches per team
Touches_by_team <- Touches_CoreData %>%
  mutate(Team = str_trim(as.character(Team))) %>%
  count(Team, name = "TotalTouches")

# Make sure TeamID is padded to match
FinalStandings <- FinalStandings %>%
  mutate(TeamID = str_pad(as.character(TeamID), width = 2, pad = "0"))

#Join touch counts with final standings
Team_Touches_Standings <- FinalStandings %>%
  left_join(Touches_by_team, by = c("TeamID" = "Team")) %>%
  filter(!is.na(TotalTouches))

#Plot with regression line : final rankings to frequency of touch

TouchFreq_vs_FinalStandings <- ggplot(Team_Touches_Standings, aes(x = Rank, y = TotalTouches)) +
  geom_point(size = 3, color = "gray30") +
  geom_text_repel(aes(label = Team), size = 3.5, max.overlaps = Inf) +  # ← Team names
  geom_smooth(method = "lm", se = FALSE, color = "blue", linewidth = 1) +
  scale_x_reverse(breaks = 1:14) +
  labs(
    title = "Final Rank vs Overall Touch Frequency",
    x = "Final Season Rank (1 = Best)",
    y = "Total Touches (Filtered)"
  ) +
  theme_minimal()

Team_Touches_Standings <- Team_Touches_Standings %>%
  mutate(
    Rank = as.numeric(Rank),
    TotalTouches = as.numeric(TotalTouches)
  )

#relationshp testing
totalseason_lineaermodel <- lm(TotalTouches ~ Rank, data = Team_Touches_Standings)
totalseason_pearson <- cor.test(Team_Touches_Standings$Rank, Team_Touches_Standings$TotalTouches, method = "pearson")

##### Nothing of interest found. There does not appear to be a relationship between end of season rank and filtered data

#possibly something with unfiltered? Should I not have filtered?

# Step 2: Use the "unfiltered" dataframe that already contains total touches per team
# Rename for consistency
Touches_by_team_unfiltered <- unfiltered %>%
  rename(TotalTouches = `Total Season Touches`)

Team_Touches_Standings_unfiltered <- FinalStandings %>%
  left_join(Touches_by_team_unfiltered, by = c("TeamID" = "TeamID")) %>%
  filter(!is.na(TotalTouches))

TouchFreq_vs_FinalStandings_unfiltered <- ggplot(Team_Touches_Standings_unfiltered, aes(x = Rank, y = TotalTouches)) +
  geom_point(size = 3, color = "gray30") +
  geom_text_repel(aes(label = Team), size = 3.5, max.overlaps = Inf) +
  geom_smooth(method = "lm", se = FALSE, color = "blue", linewidth = 1) +
  scale_x_reverse(breaks = 1:14) +
  labs(
    title = "Final Rank vs Overall Touch Frequency (Unfiltered)",
    x = "Final Season Rank (1 = Best)",
    y = "Total Touches (Unfiltered)"
  ) +
  theme_minimal()

Team_Touches_Standings_unfiltered <- Team_Touches_Standings_unfiltered %>%
  mutate(
    Rank = as.numeric(Rank),
    TotalTouches = as.numeric(TotalTouches)
  )

totalseason_lineaermodel_unfiltered <- lm(TotalTouches ~ Rank, data = Team_Touches_Standings_unfiltered)
totalseason_lineaermodel_unfiltered_summary <- summary(totalseason_lineaermodel_unfiltered)

totalseason_pearson_unfiltered <- cor.test(
  Team_Touches_Standings_unfiltered$Rank,
  Team_Touches_Standings_unfiltered$TotalTouches,
  method = "pearson"
)

#confirmed that there is not even statistical significance when looking at unfiltered data... goals etc don't matter


```

# *1. Season-Level Data Overview*

Data Summary of total touch instances, matches watched, teams included, etc.

Table 1 Below. Summary of dataset dimensions before filtering.

```{r Summary_table_season, echo=FALSE, message=FALSE, warning=FALSE}
Summary_Table_A
```

### Data Filtering Process

We apply a stepwise filtering procedure:

1. Remove touches not categorized as prosocial (i.e., exclude tactical or negative interactions)
2. Exclude resource and success based situations: goals, substitutions
3. Label remaining touches based on reciprocity: reciprocal vs. nonreciprocal

The flowchart below shows how many data points remain after each step an what data was removed from analysis.

![Data Flowchart](Flow_Chart_image.png)

Table 2 Below. Number of observations remaining at each filtering step as seen in flowchart.

```{r summary_table_flowchart, message=FALSE, warning=FALSE}
touch_summary_fowchart
```

### Team-Level Season Totals

We then assess touch frequency by team, both for the full dataset and the filtered dataset. This helps identify outliers in overall team behavior and provides input for later scaling steps.

Section Below shows unfiltered, full dataset (of all recorded touches) by team:

```{r unfiltered_total_season_by_team, echo=FALSE, message=FALSE, warning=FALSE}

unfiltered

unfiltered_graph

```

Now we take the first branch of the flowchart to the Prosocial Run-of-play touches, excluding the nonsocial touches (Tactical, collisions, negative) along with success/resource based touches such as goals and subs. This is refered to in the code as 'coredata'.

Again, below is a by team break down of Run-of-play (prosocial) touches.

```{r prosocial_total_season_by_team, echo=FALSE, message=FALSE, warning=FALSE}
filtered

filtered_plot

totalseason_parametric

# Data is normal. Therefore, parametric.
```

*Shapiro-Wilk Test showed that this data set, the total season touches filtered to the run of play is normally distributed. However, this is just for overall Touch Frequency in the season, once we break it down further, things can change.*

Boxplot comparison of the overall, unfiltered data which includes both prosocial and nonsocial touches to the core data subset used in the rest of analysis which includes only run-of-play. 

```{r tota_season_boxplot, echo=FALSE, message=FALSE, warning=FALSE}
totalseason_boxplot 
```

We begin by testing a core hypothesis: do teams that touch more throughout the season perform better by the end of the season?

# *2. Season Outcome Hypothesis*

How does season level touch frequency tie to end of season success?

```{r TouchFreq_vs_FinalStandings, echo=FALSE, message=FALSE, warning=FALSE}
TouchFreq_vs_FinalStandings
```

Appears that there is not a strong assosciation between run-of-play touch frequency, including its variation within a team, and the team's end of season results.

While no clear association emerged at the season level, we now investigate whether *match-level* touch frequency relates to outcomes like goal differential.

# By-Match Breakdown of Touch Frequency relation to End of Season Outcome

Interested in looking at by-match breakdown in relation to end of season success. Previously looked at overall touch at the season level.
This is still looking at only Prosocial, run-of-play data. 

```{r match_break_down_team, echo=FALSE, message=FALSE, warning=FALSE}
#First just Histogram of touch frequency per match across all teams
touches_permatch_plot 

#Check normalacy

touches_per_match_parametric

#NON-PARAMETIC! Do not use linear regression etc. use non-parametric alternatives.


```

*By-match level data is non-parametric according to Shapiro-Wilks test*

```{r match_break_down_team2, echo=FALSE, message=FALSE, warning=FALSE}
#By team explosion of histograms

touches_permatch_plot_teamlevel

#Ridgeline Plot
#Stacked Density plot for each team
#height of curve is relative frequency of touch

touch_permatch_ridgelineplot

#Same thing but ordered by final rank
# Visualize with boxplots 
TouchesPerGame_vs_rank

```

Could overall season success be based on a teams consistency of touch?

```{r within-team touch frequency, message=FALSE, warning=FALSE}
############################ Within-Team Variability in Touch Frequency ############################ 

# Looks at the variability a team has across matches throughout the season
# Do less variable teams do better? 

team_variation <- Touches_per_match %>%
  group_by(Team) %>%
  summarise(iqr_touch = IQR(TouchCount, na.rm = TRUE))

team_variation_ranked <- team_variation %>%
  left_join(FinalStandings %>% select(TeamID, Rank), 
            by = c("Team" = "TeamID")) %>%
  mutate(Rank = as.numeric(Rank))

team_variation_plot <- ggplot(team_variation_ranked, aes(x = Rank, y = iqr_touch)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +
  scale_x_reverse() +
  labs(
    title = "Within-Team Touch Variation (IQR) vs Final Season Rank",
    x = "Final Rank (1 = Best)",
    y = "IQR of Touches per Match"
  ) +
  theme_minimal()

team_variation_summary <- cor.test(team_variation_ranked$iqr_touch, team_variation_ranked$Rank, method = "spearman")

# No relationship between variability within-a-team and end of season rankings. 
```

*Does variation in touches by a team per-game across the season link to end of season rankings?*

```{r Variation_vs_FinalStandings, echo=FALSE, message=FALSE, warning=FALSE}
team_variation_plot

team_variation_summary
```

**No relationship between variability within-a-team and end of season rankings.**

## Scale-Touch to Account for Team Culture
(adjusting for each team's touch profile)

ScaledTouch = (TouchCount - median_touch) / iqr_touch

```{r scaledtotouchbymatch1, echo=TRUE, message=FALSE, warning=FALSE}
############### Scaling by team #####################################

# recognizing each team has their own touch culture

#Scaled touch = (touchCount - MedianTouch of team) / IQR of team

Touches_per_match_scaled <- Touches_per_match %>%
  group_by(Team) %>%
  mutate(
    median_touch = median(TouchCount, na.rm = TRUE),
    iqr_touch = IQR(TouchCount, na.rm = TRUE),
    ScaledTouch = (TouchCount - median_touch) / iqr_touch
  ) %>%
  ungroup()

Touches_per_match_scaled_ranked <- Touches_per_match_scaled %>%
  left_join(FinalStandings %>% select(TeamID, Rank), by = c("Team" = "TeamID")) %>%
  mutate(
    Rank = as.numeric(Rank),
    Team = factor(Team, levels = FinalStandings$TeamID[order(FinalStandings$Rank)])
  )

touches_permatch_scaled_plot <- ggplot(Touches_per_match_scaled_ranked, aes(x = Team, y = ScaledTouch, group = Team)) +
  geom_boxplot(fill = "lightblue", color = "black") +
  scale_x_discrete(labels = FinalStandings$TeamID[order(FinalStandings$Rank)]) +  # Optional: show TeamIDs on x-axis
  labs(
    title = "Variation of Scaled Touches per Match by Team (Ordered by Final Rank)",
    x = "Team (Ordered by Final Rank)",
    y = "Scaled Touches (Centered and Scaled by IQR)"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

*Does variation in touches by a team per-game, scaled for their individual touch profile, across the season link to end of season rankings?*

```{r scaledtotouchbymatch2, echo=TRUE, message=FALSE, warning=FALSE}
touches_permatch_scaled_plot
```

**No relationship between scaled variability within-a-team and end of season rankings.**

# *3. Outlier Analysis*

Outlier defined as 1.5 IQR

*Could extreme touch level matches be associated with with better outcomes?*

```{r Outliers, echo=FALSE, message=FALSE, warning=FALSE}

match_outcomes_outliers

# Display nicely formatted table in R Markdown
kable(outcome_summary_table, caption = "Match Outcomes by Outlier Status")

fisher_res

```

Fisher Test shows that there is a non-random association between the two groups, normal and outlier match outcomes. Accurate for small sample sizes. 

Extreme touch events seem to propose a different match outcome. If a team is way touchier than normal, it appears to be associated at success at the match level. Dive into match level analysis.

# *4. Match Outcome Hypothesis*

Is touch frequency tied to match level success?

```{r Intermatch_Variability_hypothesis_Code, echo=TRUE, message=FALSE, warning=FALSE}
# Match_Level : (Inter-Match Variability) Hypothesis
# For more information on these data frames please look at the README.md file

library(tidyverse)
library(data.table)
library(broom)
library(janitor)
library(readxl)
library(rmarkdown)
library(readr)
library(dplyr)
library(ggh4x)

############################ Inter-Match Variability Hypothesis ############################ 

# Asking: "When a team is touchy, do they score more or less goals than their opponent?"
# Note that this is still using same CoreData touches (therefore only prosocial touches and not including GF, GA, Subs etc)

# Look at overall touch frequency (no scaled) first, then do individual team scaling

# Joins dataframes (goal differentials to the touches unscaled)
Touch_Unscaled_GoalDiff_Analysis <- Touches_per_match_team %>%
  left_join(
    Matches_finalID %>% select(SeasonMatchNumber, TeamID, GoalDiff),
    by = c("SeasonMatchNumber", "Team" = "TeamID")
  )

# Visualize 
Touch_Unscaled_GoalDiff_Plot <- ggplot(Touch_Unscaled_GoalDiff_Analysis, aes(x = TouchCount, y = GoalDiff)) +
  geom_point(size = 2, alpha = 0.7) +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +
  labs(
    title = "Touch Count vs Match Goal Differential",
    x = "Touch Frequency per team per match",
    y = "Goal Differential",
    caption = "Note: Each dot represents one match outcome for a team, therefore 2 dots for each match"
  ) +
  theme_minimal()

# Note that this data is not actually continuous. a team can't win by 2.1 or 4.3 goals.

Touch_Unscaled_GoalDiff_cor_test <- cor.test(Touch_Unscaled_GoalDiff_Analysis$TouchCount,
                     Touch_Unscaled_GoalDiff_Analysis$GoalDiff,
                     method = "spearman",
                     exact = FALSE)  # exact=FALSE for larger datasets

# This alone is statistically significant. More touch associated with more goals.

######## Scaled version per team ####

# Joins dataframes (goal differentials to the touches scaled)
Touch_GoalDiff_scaled_Analysis <- Touches_per_match_scaled %>%
  left_join(
    Matches_finalID %>% select(SeasonMatchNumber, TeamID, GoalDiff),
    by = c("SeasonMatchNumber", "Team" = "TeamID")
  )

# Visualize 
Touch_GoalDiff_scaled_plot <- ggplot(Touch_GoalDiff_scaled_Analysis, aes(x = ScaledTouch, y = GoalDiff)) +
  geom_point(size = 2, alpha = 0.7) +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +
  labs(
    title = "Touch Count Deviation vs Match Goal Differential",
    x = "Scaled Touch by Team Profile",
    y = "Goal Differential",
    caption = "Note: Each dot represents one match outcome for a team, therefore 2 dots for each match"
  ) +
  theme_minimal()

# Spearman:
Touch_Scaled_GoalDiff_cor_test <- cor.test(
  Touch_GoalDiff_scaled_Analysis$ScaledTouch,
  Touch_GoalDiff_scaled_Analysis$GoalDiff,
  method = "spearman",
  exact = FALSE  # use FALSE for larger datasets
)

# Both Scaled and Unscaled are quite similar! Both are statistically significant.

Touch_GoalDiff_scaled_Analysis_plot <- ggplot(Touch_GoalDiff_scaled_Analysis, aes(x = ScaledTouch, y = GoalDiff)) +
  geom_point(size = 2, alpha = 0.7) +
  geom_vline(xintercept = 0, linetype = "dotted", color = "red", size = 0.8) +
  ggh4x::facet_wrap2(~ Team, ncol = 7, strip.position = "top", axes = "all") +
  coord_cartesian(xlim = c(-4, 4)) +
  labs(
    title = "Touch Count Deviation vs Match Goal Differential by Team",
    x = "Scaled Touch by Team Profile",
    y = "Goal Differential",
    caption = "Each dot represents one match outcome for a team"
  ) +
  theme_minimal() +
  theme(
    strip.text = element_text(size = 10),
    plot.title = element_text(hjust = 0.5),
    panel.background = element_rect(fill = "white", color = "gray30", size = 0.8),
    panel.spacing = unit(1, "lines")
  )

```

Are high touch frequency matches associated with high goal differentials?

Start with unscaled, not adjusted to the team's individual profile:

```{r unscaled_by_match_plots, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
Touch_Unscaled_GoalDiff_Plot

Touch_Unscaled_GoalDiff_cor_test 
```

*Spearman test shows significance. Higher touch rates in a match are associated to wins.*

Scaled, as before, to the team's individual profile:

```{r scaled_by_match_plots, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

# Visualize 
Touch_GoalDiff_scaled_plot

# Spearman:
Touch_Scaled_GoalDiff_cor_test

# Both Scaled and Unscaled are quite similar! Both are statistically significant.

Touch_GoalDiff_scaled_Analysis_plot 
```

*Both show statistical significance, Matches in where teams touch more, both overall frequency and compared to their individual profile, are associated with higher goal differentials.*

# *5. Type of Touch*

Looking at TYPE of Touch now, not only frequency. 

```{r REcriprocitycode, echo=TRUE, message=TRUE, warning=FALSE}
#Reciprocity
# For more information on these data frames please look at the README.md file

library(tidyverse)
library(data.table)
library(broom)
library(janitor)
library(readxl)
library(rmarkdown)
library(readr)
library (dplyr)
library(plotly)
library(mgcv)
library(ggplot2)
library(forcats)
library(ggridges)
library(DescTools)
library(dplyr)
library(tidyr)
library(ggplot2)
library(stringr)

############################ Reciprocal/Non-Reciprocal ############################
# Define situations to exclude
exclude_situations <- c("GF", "GA", "SUB")

# Filter and calculate touches by reciprocity group per team (excluding specified situations)
Reciprocity_by_Team_filtered <- Touches_ReciprocalNonRecip %>%
  filter(!is.na(Reciprocity_Group)) %>%
  filter(!Situation %in% exclude_situations) %>%   # exclude GF, GA, SUB
  group_by(Team, Reciprocity_Group) %>%
  summarise(TouchCount = n(), .groups = "drop") %>%
  pivot_wider(names_from = Reciprocity_Group, values_from = TouchCount, values_fill = 0) %>%
  mutate(
    Reciprocal_To_NonRecip_Ratio = Reciprocal / NonReciprocal,
    DataFlag = if_else(Reciprocal + NonReciprocal == 0, "No Touch Data", "Data Available")
  )

lollipop_season_recip_byteam_plot <- ggplot(Reciprocity_by_Team_filtered %>% filter(DataFlag == "Data Available"), 
       aes(x = reorder(Team, Reciprocal_To_NonRecip_Ratio), y = Reciprocal_To_NonRecip_Ratio)) +
  geom_segment(aes(xend = Team, y = 0, yend = Reciprocal_To_NonRecip_Ratio), color = "gray70") +
  geom_point(color = "steelblue", size = 4) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "red") +
  coord_flip() +
  labs(
    title = "Reciprocal to Nonreciprocal Touch Ratio by Team (Season Aggregate)",
    x = "Team",
    y = "Reciprocal / Nonreciprocal Touch Ratio"
  ) +
  theme_minimal()

# Join with Final Standings to get rank info
Reciprocal_vs_Rank_filtered <- FinalStandings %>%
  mutate(TeamID = str_pad(as.character(TeamID), width = 2, pad = "0")) %>%
  left_join(Reciprocity_by_Team_filtered, by = c("TeamID" = "Team")) %>%
  filter(DataFlag == "Data Available")  # Optional: exclude teams with no data

# Plot reciprocal ratio vs final season rank
Reciprocal_vs_Rank_Plot_filtered <- ggplot(Reciprocal_vs_Rank_filtered, aes(x = Rank, y = Reciprocal_To_NonRecip_Ratio)) +
  geom_point(size = 3, color = "steelblue") +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  scale_x_reverse(breaks = 1:max(Reciprocal_vs_Rank_filtered$Rank)) +
  labs(
    title = "Reciprocal Touch Ratio vs Final Season Rank per Team (Filtered Situations)",
    subtitle = "Higher ratios may reflect stronger intra-team cohesion",
    caption = "Note: Each dot represents one team",
    x = "Team Final Season Rank (1 = Best)",
    y = "Reciprocal to NonReciprocal Touch Ratio"
  ) +
  theme_minimal()

# Check normality of the ratio
ratio_parametric_filtered <- shapiro.test(Reciprocal_vs_Rank_filtered$Reciprocal_To_NonRecip_Ratio)

# Perform Pearson correlation (parametric)
ratio_recip_pearson_result_filtered <- cor.test(
  Reciprocal_vs_Rank_filtered$Reciprocal_To_NonRecip_Ratio,
  Reciprocal_vs_Rank_filtered$Rank,
  method = "pearson"
)

# Not statistically significant, suggesting that the reciprocal/nonreciprocal ratio is linked
# to the GF, SUBs, and GA situations. 
# What is going on here? Perhaps GF, GA, and SUB all have high reciprocal touch 
# Step 1 & 2: Summarize counts and proportions by Situation and Reciprocity_Group

library(scales)

# Categorize situations into GF, GA, SUB, or Other
Touches_ReciprocalNonRecip <- Touches_ReciprocalNonRecip %>%
  mutate(
    Situation_Bucket = case_when(
      Situation %in% c("GF", "GA", "SUB") ~ Situation,
      TRUE ~ "Other"
    )
  )

# Summarize counts per Reciprocity_Group and Situation_Bucket
situation_summary_reciprocity <- Touches_ReciprocalNonRecip %>%
  filter(!is.na(Reciprocity_Group)) %>%
  group_by(Reciprocity_Group, Situation_Bucket) %>%
  summarise(Count = n(), .groups = "drop") %>%
  group_by(Reciprocity_Group) %>%
  mutate(
    Percent = Count / sum(Count)
  ) %>%
  ungroup()

# Plot grouped bar chart with percent on y-axis
situation_summary_reciprocity_plot <- ggplot(situation_summary_reciprocity, aes(x = Reciprocity_Group, y = Percent, fill = Situation_Bucket)) +
  geom_col(position = position_dodge(width = 0.8), color = "black") +  # side-by-side bars
  scale_y_continuous(labels = percent_format()) +
  labs(
    title = "Proportion of Situations by Reciprocity Group",
    x = "",
    y = "Percentage of Touches",
    fill = "Situation"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(size = 12),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10)
  )

#### Okay ya, so the ratio of a teams reciprocity is significantly different when accounting for GF and SUBS.

######## Lets look at reciprocal and non recriprocal totally separately ####
# Sum total touches by team for reciprocal
Recip_by_team <- Reciprocal_Touches %>%
  group_by(Team) %>%
  summarise(Reciprocal = n(), .groups = "drop")

# Sum total touches by team for nonreciprocal
Nonrecip_by_team <- NonReciprocal_Touches %>%
  group_by(Team) %>%
  summarise(NonReciprocal = n(), .groups = "drop")

# Join with FinalStandings (make sure TeamID format matches 'Team')
FinalStandings <- FinalStandings %>%
  mutate(TeamID = str_pad(as.character(TeamID), width = 2, pad = "0"))

# Join reciprocal touches with standings
Recip_vs_rank <- FinalStandings %>%
  left_join(Recip_by_team, by = c("TeamID" = "Team")) %>%
  filter(!is.na(Reciprocal)) %>%
  mutate(Rank = as.numeric(Rank))

# Join nonreciprocal touches with standings
NonRecip_vs_rank <- FinalStandings %>%
  left_join(Nonrecip_by_team, by = c("TeamID" = "Team")) %>%
  filter(!is.na(NonReciprocal)) %>%
  mutate(Rank = as.numeric(Rank))

# Correlation: Reciprocal vs Rank
cor_recip <- cor.test(Recip_vs_rank$Reciprocal, Recip_vs_rank$Rank, method = "spearman")

# Correlation: Nonreciprocal vs Rank
cor_nonrecip <- cor.test(NonRecip_vs_rank$NonReciprocal, NonRecip_vs_rank$Rank, method = "spearman")

# Plot Reciprocal touches vs Rank
recip_touch_vs_rank_plot <- ggplot(Recip_vs_rank, aes(x = Rank, y = Reciprocal)) +
  geom_point(color = "blue", size = 3) +
  geom_smooth(method = "lm", se = FALSE, color = "darkblue") +
  scale_x_reverse(breaks = 1:max(Recip_vs_rank$Rank)) +
  labs(title = "Reciprocal Touches vs Final Season Rank",
       x = "Final Season Rank (1 = Best)",
       y = "Total Reciprocal Touches") +
  theme_minimal()

# Plot NonReciprocal touches vs Rank
nonrecip_touch_vs_rank_plot <- ggplot(NonRecip_vs_rank, aes(x = Rank, y = NonReciprocal)) +
  geom_point(color = "red", size = 3) +
  geom_smooth(method = "lm", se = FALSE, color = "darkred") +
  scale_x_reverse(breaks = 1:max(NonRecip_vs_rank$Rank)) +
  labs(title = "NonReciprocal Touches vs Final Season Rank",
       x = "Final Season Rank (1 = Best)",
       y = "Total NonReciprocal Touches") +
  theme_minimal()

#### Reciprocal touches seem meaningfully associated with better performance, while nonrecip touches do not

# ratio

library(dplyr)
library(ggplot2)

# Filter data to exclude GF, GA, SUB situations
filtered_touches_recip_nonrecip <- Touches_ReciprocalNonRecip %>%
  filter(!Situation %in% c("GF", "GA", "SUB")) %>%
  filter(!is.na(Reciprocity_Group))

# Calculate reciprocal and nonreciprocal counts per team per match
touches_per_match_ratio <- filtered_touches_recip_nonrecip %>%
  group_by(Team, SeasonMatchNumber, Reciprocity_Group) %>%
  summarise(TouchCount = n(), .groups = "drop") %>%
  pivot_wider(names_from = Reciprocity_Group, values_from = TouchCount, values_fill = 0) %>%
  mutate(Recip_NonRecip_Ratio = Reciprocal / NonReciprocal)

# Join rank info to your per-match data
touches_per_match_ranked <- touches_per_match_ratio %>%
  left_join(FinalStandings %>% select(TeamID, Rank), by = c("Team" = "TeamID"))

# Convert Team to factor ordered by Rank
touches_per_match_ranked <- touches_per_match_ranked %>%
  mutate(Team = factor(Team, levels = FinalStandings %>% arrange(Rank) %>% pull(TeamID)))

# Create factor levels ordered by rank ascending, then reverse them
touches_per_match_ranked <- touches_per_match_ranked %>%
  mutate(Team = factor(Team, levels = rev(FinalStandings %>% arrange(Rank) %>% pull(TeamID))))

# Now plot using this ordered factor
touches_per_match_ranked_plot <- ggplot(touches_per_match_ranked, aes(x = Team, y = Recip_NonRecip_Ratio)) +
  geom_boxplot(fill = "lightblue", outlier.colour = "red", outlier.size = 2) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "red") +
  labs(
    title = "Per Match Spread of Reciprocal to Nonreciprocal Touch Ratios by Team (Ordered by End of Season Rank)",
    x = "Team (Ordered by Rank)",
    y = "Reciprocal / Nonreciprocal Touch Ratio"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Join with Matches_finalID to get goal differential
touches_ratio_goaldiff <- touches_per_match_ratio %>%
  left_join(Matches_finalID %>% select(SeasonMatchNumber, TeamID, GoalDiff),
            by = c("SeasonMatchNumber", "Team" = "TeamID")) %>%
  filter(!is.na(Recip_NonRecip_Ratio))  # remove NA ratios if any (e.g. NonReciprocal = 0)

# Plot reciprocal:nonreciprocal ratio vs goal differential
ratio_vs_goaldiff_plot <- ggplot(touches_ratio_goaldiff, aes(x = Recip_NonRecip_Ratio, y = GoalDiff)) +
  geom_point(alpha = 0.7, color = "darkgreen", size = 2) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  labs(
    title = "Reciprocal to NonReciprocal Touch Ratio vs Goal Differential",
    x = "Reciprocal : NonReciprocal Touch Ratio (Filtered Situations)",
    y = "Goal Differential",
    caption = "Each point = one team in one match"
  ) +
  theme_minimal()

# Spearman correlation test between ratio and goal differential
spearman_ratio_goaldiff <- cor.test(
  touches_ratio_goaldiff$Recip_NonRecip_Ratio,
  touches_ratio_goaldiff$GoalDiff,
  method = "spearman"
)


###With a team profile profile (difference from normal)####

# Season level ratio per team (filtered situations)
season_ratio_by_team <- Touches_ReciprocalNonRecip %>%
  filter(!is.na(Reciprocity_Group)) %>%
  filter(!Situation %in% c("GF", "GA", "SUB")) %>%
  group_by(Team, Reciprocity_Group) %>%
  summarise(TouchCount = n(), .groups = "drop") %>%
  pivot_wider(names_from = Reciprocity_Group, values_from = TouchCount, values_fill = 0) %>%
  mutate(Season_Recip_NonRecip_Ratio = Reciprocal / NonReciprocal)

match_ratio_by_team <- Touches_ReciprocalNonRecip %>%
  filter(!Situation %in% c("GF", "GA", "SUB")) %>%
  filter(!is.na(Reciprocity_Group)) %>%
  group_by(Team, SeasonMatchNumber, Reciprocity_Group) %>%
  summarise(TouchCount = n(), .groups = "drop") %>%
  pivot_wider(names_from = Reciprocity_Group, values_from = TouchCount, values_fill = 0) %>%
  mutate(Match_Recip_NonRecip_Ratio = Reciprocal / NonReciprocal)

match_vs_season_ratio <- match_ratio_by_team %>%
  left_join(season_ratio_by_team %>% select(Team, Season_Recip_NonRecip_Ratio), by = "Team")

match_vs_season_ratio <- match_vs_season_ratio %>%
  mutate(
    Ratio_Deviation = Match_Recip_NonRecip_Ratio - Season_Recip_NonRecip_Ratio
  )

match_vs_season_ratio <- match_vs_season_ratio %>%
  left_join(Matches_finalID %>% select(SeasonMatchNumber, TeamID, GoalDiff),
            by = c("SeasonMatchNumber", "Team" = "TeamID"))

# Scatter plot with smooth line
match_vs_season_ratio_plot <- ggplot(match_vs_season_ratio, aes(x = Ratio_Deviation, y = GoalDiff)) +
  geom_point(alpha = 0.7, color = "darkgreen") +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  labs(
    title = "Deviation of Match to the Season Reciprocal Touch Ratio vs Goal Differential",
    x = "Match-to-Season Reciprocal:NonReciprocal Ratio Deviation",
    y = "Goal Differential"
  ) +
  theme_minimal()

# Spearman correlation test for significance
cor.test(match_vs_season_ratio$Ratio_Deviation, match_vs_season_ratio$GoalDiff, method = "spearman")

```

# Season-Level Reciprocity Ratio

Reciprocity Ratio = Reciprocal Touches / Non-Reciprocal Touches

Calculated each team's ratio of reciprocal to non-reciprocal touches (Run of play filtered) over the entire season.

```{r recipratioteamplot, echo=FALSE, message=FALSE, warning=FALSE}
lollipop_season_recip_byteam_plot

# Plot reciprocal ratio vs final season rank
Reciprocal_vs_Rank_Plot_filtered

# Check normality of the ratio
ratio_parametric_filtered

# Perform Pearson correlation (parametric)
ratio_recip_pearson_result_filtered

```

**Data found to be normally distributed**

*Not statistically significant.* *Touch Ratio does not associate with end-of-season outcomes.* Lets look at match level analysis.

# Match-Level Reciprocity Ratio

Examine whether match-level reciprocity ratio is linked to goal differential

```{r permatchratioplots, echo=FALSE, message=FALSE, warning=FALSE}

# Now plot using this ordered factor
touches_per_match_ranked_plot 

# Plot reciprocal:nonreciprocal ratio vs goal differential
ratio_vs_goaldiff_plot

# Spearman correlation test between ratio and goal differential
spearman_ratio_goaldiff

```

**Data found to NOT be normally distributed**

*A very weak positive relationship is found: as the reciprocal to non-recip touch ratio increases, goal differential tends to increase slightly.*

## Match-Level Deviation from each Team's Reciprocity Profile

Match-Level Deviation = (Team's Match Ratio) - (Team's Average Ratio)

```{r matchratiodeviation, echo=FALSE, message=FALSE, warning=FALSE}
###With a team profile profile (difference from normal)####

match_ratio_by_team

# Scatter plot with smooth line
match_vs_season_ratio_plot

# Spearman correlation test for significance
cor.test(match_vs_season_ratio$Ratio_Deviation, match_vs_season_ratio$GoalDiff, method = "spearman")
```

*A weak but positive correlation was found between match-evel deviations from a team's season-average reciprocity ratio and goal differential. Teams perform slightly better in matches where they exhibit higher than usual reciprocity.*

# *6. Social Network Strength*

We explored whether the way touches are distributed across players within a team reflects its internal structure — and whether this structure relates to performance.
Dove into the Touch Distribution across players within teams

### Cleaning and Validating Player Interaction Data

We began by cleaning the `ToucherNumber`, `ToucheeNumber`, and `PlayersInvolved` fields to correct typos and inconsistencies. This preprocessing ensures that the subsequent player-level analyses are based on verified, interpretable entries. For example, values like "10. 12" were converted to "10,12".

```{r social network analysis, echo=TRUE, message=FALSE, warning=FALSE}
# Social Network Strength Hypothesis
# For more information on these data frames please look at the README.md file

library(tidyverse)
library(data.table)
library(broom)
library(janitor)
library(readxl)
library(rmarkdown)
library(readr)
library (dplyr)
library(plotly)
library(mgcv)
library(ggplot2)
library(forcats)
library(ggridges)
library(DescTools)

############################ Social Network Strength ############################

#Creates Dataframe that Flags values that don't match with requirements of strings, jersey numbers, G, SU, ??
#Cleans common typos (which were many)
Touches_players_flagged <- Touches_ProSocial %>%
  mutate(
    ToucherNumber = as.character(ToucherNumber),
    ToucheeNumber = as.character(ToucheeNumber),
    PlayersInvolved = as.character(PlayersInvolved),
    PlayersInvolved = PlayersInvolved %>%
      str_replace_all("\\.\\s+", ",") %>%           # fix "10. 12" → "10,12"
      str_remove_all("[\"'`:;.`]") %>%              # Remove unwanted punctuation
      str_replace_all("\\s*,\\s*", ",") %>%         # Normalize commas and spacing
      str_replace_all("\\s+", "") %>%               # Remove stray spaces
      str_replace_all("(?<=\\d{2})(?=\\d{2}$)", ",") %>%       # Insert comma in "1210" → "12,10"
      str_replace(",+$", "") %>%                    # Remove trailing commas
      str_trim(),                                   # Clean up leading/trailing space 
    
    
    # Valid if it's a number, "G", "SU", or "??"
    ToucherNumber_Valid = str_detect(ToucherNumber, "^\\d{1,2}$|^G$|^SU$|^\\?\\?$"),
    ToucheeNumber_Valid = str_detect(ToucheeNumber, "^\\d{1,2}$|^G$|^SU$|^\\?\\?$"),
    
    # Valid PlayersInvolved: at least two elements (numbers or ?? or SU), comma-separated
    PlayersInvolved_List = str_split(PlayersInvolved, ",\\s*"),
    PlayersInvolved_Valid = map_lgl(PlayersInvolved_List, function(players) {
      cleaned <- str_trim(players)
      all_valid <- all(str_detect(cleaned, "^\\d+$|^\\?\\?$|^SU$"))
      has_multiple <- length(cleaned) >= 2
      all_valid && has_multiple
    })
  )

#Splits "12,04,09" back into "12, 04, 09"
Touches_players_flagged <- Touches_players_flagged %>%
  mutate(PlayersInvolved = str_split(PlayersInvolved, ","))

#Ignore those flagged values for now (fix them before final paper)
Touches_players_final <- Touches_players_flagged %>%
  filter(
    ToucherNumber_Valid,
    ToucheeNumber_Valid,
    PlayersInvolved_Valid
  )

############################ Player Concentration | Social Network Strength ############################

#########Histograms for Toucher by team (creates 14 histograms for team by team analysis)

# Count number of times each player was the Toucher within each team
toucher_counts <- Touches_players_final %>%
  filter(!is.na(ToucherNumber) & ToucherNumber != "G" & Reciprocal == "N") %>%
  group_by(Team, ToucherNumber) %>%
  summarise(TouchCount = n(), .groups = "drop")

toucher_histo <- ggplot(toucher_counts, aes(x = ToucherNumber, y = TouchCount)) +
  geom_col(fill = "steelblue") +
  facet_wrap(~ Team, scales = "free_x") +
  labs(
    title = "Toucher Frequency by Player Jersey Number",
    x = "Player (ToucherNumber)",
    y = "Number of Touches"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5),
    strip.text = element_text(face = "bold")
  )

toucher_team_gini <- toucher_counts %>%
  group_by(Team) %>%
  summarise(Gini = Gini(TouchCount)) %>%
  arrange(desc(Gini))

# Use Gini order for Team factor levels
toucher_counts <- toucher_counts %>%
  mutate(Team = factor(Team, levels = toucher_team_gini$Team))

# Plot with teams ordered by Gini (highest concentration at top)
Toucher_plot_gini_ordered <- ggplot(toucher_counts, aes(x = TouchCount, y = Team, fill = Team)) +
  geom_density_ridges(alpha = 0.7, scale = 1) +
  labs(
    title = "Distribution of Toucher Counts per Player by Team (Ordered by Gini Coefficient)",
    x = "Number of Touches",
    y = "Team (High to Low Concentration)"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

#########Histograms for Touchee by team (creates 14 histograms for team by team analysis)

# Count number of times each player was the Touchee within each team
touchee_counts <- Touches_players_final %>%
  filter(!is.na(ToucheeNumber) & ToucheeNumber != "G" & Reciprocal == "N") %>%
  group_by(Team, ToucheeNumber) %>%
  summarise(TouchCount = n(), .groups = "drop")

Touchee_histo <- ggplot(touchee_counts, aes(x = ToucheeNumber, y = TouchCount)) +
  geom_col(fill = "steelblue") +
  facet_wrap(~ Team, scales = "free_x") +
  labs(
    title = "Touchee Frequency by Player Jersey Number",
    x = "Player (ToucheeNumber)",
    y = "Number of Touches"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5),
    strip.text = element_text(face = "bold")
  )

# Calculate Gini coefficient for touchee counts per team
touchee_team_gini <- touchee_counts %>%
  group_by(Team) %>%
  summarise(Gini = Gini(TouchCount)) %>%
  arrange(desc(Gini))

# Order Team factor by touchee Gini (descending)
touchee_counts <- touchee_counts %>%
  mutate(Team = factor(Team, levels = touchee_team_gini$Team))

# Ridge plot for touchee counts ordered by Gini
Touchee_plot_gini_ordered <- ggplot(touchee_counts, aes(x = TouchCount, y = Team, fill = Team)) +
  geom_density_ridges(alpha = 0.7, scale = 1) +
  labs(
    title = "Distribution of Touchee Counts per Player by Team (Ordered by Gini Coefficient)",
    x = "Number of Touches",
    y = "Team (High to Low Concentration)"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

############# Touchee vs Toucher involvement league wide ##################333

# Combine toucher and touchee counts per player and team
combined_counts <- toucher_counts %>%
  rename(Player = ToucherNumber, ToucherCount = TouchCount) %>%
  full_join(
    touchee_counts %>% rename(Player = ToucheeNumber, ToucheeCount = TouchCount),
    by = c("Team", "Player")
  ) %>%
  mutate(
    ToucherCount = replace_na(ToucherCount, 0),
    ToucheeCount = replace_na(ToucheeCount, 0),
    TotalTouches = ToucherCount + ToucheeCount
  ) %>%
  filter(TotalTouches >= 10)  # filter players with 10 or more combined touches

# Scatter plot league-wide
Toucher_v_Touchee_plot_global <- ggplot(combined_counts, aes(x = ToucheeCount, y = ToucherCount)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  labs(
    title = "League-wide Player Touch Counts: Touchee vs. Toucher",
    x = "Touchee Count (Touches Received)",
    y = "Toucher Count (Touches Initiated)"
  ) +
  theme_minimal()

combined_counts_team <- toucher_counts %>%
  rename(Player = ToucherNumber, ToucherCount = TouchCount) %>%
  full_join(
    touchee_counts %>% rename(Player = ToucheeNumber, ToucheeCount = TouchCount),
    by = c("Team", "Player")
  ) %>%
  mutate(
    ToucherCount = replace_na(ToucherCount, 0),
    ToucheeCount = replace_na(ToucheeCount, 0),
    TotalTouches = ToucherCount + ToucheeCount
  ) %>%
  filter(TotalTouches >= 10)  # keep only active players

Toucher_v_Touchee_plot_team <- ggplot(combined_counts_team, aes(x = ToucheeCount, y = ToucherCount)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  facet_wrap(~ Team, scales = "free") +
  labs(
    title = "Player Touch Counts: Touchee vs. Toucher by Team (≥10 touches)",
    x = "Touchee Count (Touches Received)",
    y = "Toucher Count (Touches Initiated)"
  ) +
  theme_minimal()

team_correlations_touchervtouchee <- combined_counts %>%
  group_by(Team) %>%
  summarise(
    cor = cor(ToucheeCount, ToucherCount, method = "pearson")
  ) %>%
  arrange(desc(cor))

combined_counts_ratio <- toucher_counts %>%
  rename(Player = ToucherNumber, ToucherCount = TouchCount) %>%
  full_join(
    touchee_counts %>% rename(Player = ToucheeNumber, ToucheeCount = TouchCount),
    by = c("Team", "Player")
  ) %>%
  mutate(
    ToucherCount = replace_na(ToucherCount, 0),
    ToucheeCount = replace_na(ToucheeCount, 0),
    TotalTouches = ToucherCount + ToucheeCount,
    RoleRatio = (ToucherCount + 1) / (ToucheeCount + 1)
  ) %>%
  filter(TotalTouches >= 10)  # focus on active players

combined_ratios_plot <- ggplot(combined_counts_ratio, aes(x = Team, y = RoleRatio)) +
  geom_boxplot() +
  labs(
    title = "Distribution of Player Role Ratios by Team",
    x = "Team",
    y = "Toucher / Touchee Ratio"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "red")  # line at balanced ratio

#########Histograms for players involved in any touch event, as toucher, touchee or group (creates 14 histograms for team by team analysis)

# Properly split and unnest
player_counts <- Touches_players_final %>%
  select(Team, PlayersInvolved) %>%
  separate_rows(PlayersInvolved, sep = ",\\s*") %>%
  mutate(PlayersInvolved = str_trim(PlayersInvolved)) %>%
  filter(PlayersInvolved != "") %>%
  group_by(Team, PlayersInvolved) %>%
  summarise(TouchCount = n(), .groups = "drop") %>%
  arrange(Team, desc(TouchCount))

player_gini <- player_counts %>%
  group_by(Team) %>%
  summarise(Gini = Gini(TouchCount)) %>%
  arrange(desc(Gini))

player_counts <- player_counts %>%
  mutate(Team = factor(Team, levels = player_gini$Team))

player_involved_histo <- ggplot(player_counts, aes(x = fct_reorder(PlayersInvolved, -TouchCount), y = TouchCount)) +
  geom_col(fill = "steelblue") +
  facet_wrap(~ Team, scales = "free_x") +
  labs(
    title = "Player Touch Involvement (PlayersInvolved Column)",
    subtitle = "Each bar shows one player's total involvement across the season",
    x = "Player Jersey / Code",
    y = "Touch Count"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, size = 8),
    strip.text = element_text(face = "bold")
  )

player_involved_ridgeplot <- ggplot(player_counts, aes(x = TouchCount, y = Team, fill = Team)) +
  geom_density_ridges(alpha = 0.7, scale = 1) +
  labs(
    title = "Distribution of Player Touch Involvement by Team (Ordered by Gini)",
    x = "Touch Count (Player Involvement)",
    y = "Team"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

#What Anne asked for:
# 1. Calculate team mean touch count
player_counts_mean <- player_counts %>%
  group_by(Team) %>%
  mutate(TeamMeanTouch = mean(TouchCount)) %>%
  ungroup()

# Calculate relative touch count per player (touches minus team mean)
player_counts_mean <- player_counts_mean %>%
  mutate(TouchCount_relative = TouchCount - TeamMeanTouch)

# Optional: reorder teams by Gini or other metric
player_gini <- player_counts_mean %>%
  group_by(Team) %>%
  summarise(Gini = Gini(TouchCount)) %>%
  arrange(desc(Gini))

player_counts_mean <- player_counts_mean %>%
  mutate(Team = factor(Team, levels = player_gini$Team))

# Plot ridge plot with TouchCount_relative on x-axis, Team on y-axis
player_counts_mean_plot <- ggplot(player_counts_mean, aes(x = TouchCount_relative, y = Team, fill = Team)) +
  geom_density_ridges(alpha = 0.7, scale = 1) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +  # line at team mean
  labs(
    title = "Player Touch Involvement Relative to Team Mean",
    subtitle = "Negative = below team mean, Positive = above team mean",
    x = "Touch Count Difference from Team Mean",
    y = "Team"
  ) +
  theme_minimal() +
  theme(legend.position = "none")



#Compare gini coeeficient to final season standings. 

player_gini <- player_gini %>%
  mutate(Team = as.numeric(Team),
         Team = str_trim(Team))

FinalStandings <- FinalStandings %>%
  mutate(TeamID = as.numeric(TeamID),
         TeamID = str_trim(TeamID))

# Join player involvement Gini with final standings
gini_with_rank <- player_gini %>%
  inner_join(FinalStandings, by = c("Team" = "TeamID"))

# Scatter plot: Rank vs. Gini coefficient
gini_rank_plot <- ggplot(gini_with_rank, aes(x = Rank, y = Gini)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  scale_x_reverse(breaks = sort(unique(gini_with_rank$Rank))) +  # Best team on left
  labs(
    title = "Player Touch Involvement Concentration vs. Final Season Rank",
    x = "Final Season Rank (1 = Best)",
    y = "Gini Coefficient of Player Touch Involvement"
  ) +
  theme_minimal()

# Calculate Spearman correlation between rank and Gini
spearman_corr_gini <- cor(gini_with_rank$Rank, gini_with_rank$Gini, method = "spearman")

# What if we do this by game? Again, with goal differential? Where a more evenly spread game (gini coefficient) could produce a better goal differential?
```

---

## Player-Level Involvement: Team Touch Hierarchies

### Histograms per Team

To visualize player-level involvement, we plotted how often each athlete initiated (toucher) or received (touchee) a touch. Teams vary widely in how evenly touches are distributed across players.

```{r histogramforsocialnet, echo=FALSE, message=FALSE, warning=FALSE}
toucher_histo
Touchee_histo
```

### Ridgeplots by Team Ordered by Gini

To quantify touch distribution within each team, we calculated a Gini coefficient per team. A higher Gini suggests that few players dominate the team's touch activity. The ridgeplots below highlight these disparities.

```{r histogramforsocialnet2, echo=FALSE, message=FALSE, warning=FALSE}
Toucher_plot_gini_ordered
Touchee_plot_gini_ordered
```

A high Gini indicates that touches are concentrated among a a few players; a low Gini suggests a more even distribution. 

### Combined Role Scatterplot (Toucher vs. Touchee)

We explored whether certain players consistently acted as both initiators and receivers of touch events. At the league level, there's a moderate positive relationship — players who initiate more also tend to receive more. Within teams, these patterns vary.

```{r rolescatter, echo=FALSE, message=FALSE, warning=FALSE}
Toucher_v_Touchee_plot_global
Toucher_v_Touchee_plot_team
team_correlations_touchervtouchee
```


---

### Role Ratio and Centralization: Team-Level Patterns

We calculated a role ratio for each player: touches initiated / touches received. A ratio near 1 suggests balanced involvement. Some teams had wider spreads than others, indicating specialized player roles.

Role Ratio = tuoches initiated / touches received

A ratio near 1 suggests balanced participation.

```{r echo=FALSE, message=FALSE, warning=FALSE}
combined_ratios_plot
```

---

### Global Player Involvement: Across All Roles

We also considered a broader definition of touch involvement using the `PlayersInvolved` field. This includes all players present in the interaction, not just the toucher or touchee. Patterns echoed those seen in the prior plots, with a few players per team often dominating touch events. Therefore, this also includes group events. 

```{r echo=FALSE, message=FALSE, warning=FALSE}
player_involved_histo
player_involved_ridgeplot
```

---

## Relative Contribution: Within-Team Normalization

To highlight intra-team roles, we normalized each player's involvement relative to their team average. A player well above the red line (mean) suggests high centrality within the touch network.

```{r echo=FALSE, message=FALSE, warning=FALSE}
player_counts_mean_plot
```

To better understand team hierarchies, we normalized each player’s touch count relative to their own team’s average. Players well above the team mean (indicated by a red line in the plot) appeared as hubs in their team’s social network. This revealed that some teams had clear focal players, while others were more egalitarian.

---

## Gini vs. Final Rank: Do Balanced Teams Win?

Finally, we tested whether teams with more evenly distributed player involvement (lower Gini) performed better across the season. Results suggest a moderate negative correlation between Gini coefficient and final rank — teams with more egalitarian touch networks tended to finish higher.

```{r echo=FALSE, message=FALSE, warning=FALSE}
gini_rank_plot
spearman_corr_gini  # Spearman's rho
```


# *7. Time-Elapsed Touch Frequency*

Examines how Run-of-play touch frequency evolves throughout a match.
In this section, we examine how prosocial touch behavior evolves throughout the duration of a match. Specifically, we analyze the frequency of touches as a function of **match time**, using data from all eligible prosocial touch events across the season.

### Data Preparation
We filtered out negative, coaching, or administrative events (`TA`, `CO`, `NEG`) and excluded non-play situations like goals, substitutions, and cards (`GF`, `GA`, `SUB`). Time stamps for each touch were converted to total seconds and normalized to create a **percent-of-match-completion** variable.

Therfore, looks at Run-of-play (CoreData) touches.

```{r Touch_by_time, echo=TRUE, message=FALSE, warning=FALSE}
# Libraries
library(tidyverse)
library(data.table)
library(broom)
library(janitor)
library(readxl)
library(rmarkdown)
library(readr)
library(dplyr)
library(ggsignif)

#############
# Section A: Prep data
#############

# Correct TotalMatchSeconds computation
Matches_final <- Matches_final %>%
  mutate(
    TeamID = str_sub(MatchID, 1, 2),
    FirstHalfSecs = convert_mmss_to_seconds(as.numeric(FirstHalfLength)),
    SecondHalfSecs = convert_mmss_to_seconds(as.numeric(SecondHalfLength)),
    TotalMatchSeconds = FirstHalfSecs + SecondHalfSecs
  )

# Step 1: Match-by-match seconds played
player_match_seconds <- match_player_entries %>%
  group_by(SeasonMatchNumber, TeamID, Player) %>%
  summarise(
    MatchSecondsPlayed = sum(MatchSecondsPlayed, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(SeasonMatchNumber, TeamID, Player)

# Step 2: Players with ≥ match_cutoff matches, only looking at players with a large enough data set a piece
match_cutoff <- 10
players_with_cutoff_matches <- player_match_seconds %>%
  group_by(TeamID, Player) %>%
  summarise(
    NumMatchesPlayed = n_distinct(SeasonMatchNumber),
    .groups = "drop"
  ) %>%
  filter(NumMatchesPlayed >= match_cutoff)

# Step 3: Explode Goals data
goals_exploded <- Matches_final %>%
  mutate(
    MatchID = str_pad(MatchID, width = 4, pad = "0"),
    TeamID  = str_sub(MatchID, 1, 2),
    FirstHalfSecs = convert_mmss_to_seconds(as.numeric(FirstHalfLength))
  ) %>%
  select(SeasonMatchNumber, MatchID, TeamID, GoalsInMatchFor, FirstHalfLength, SecondHalfLength, FirstHalfSecs) %>%
  filter(!is.na(GoalsInMatchFor) & GoalsInMatchFor != "" & !(GoalsInMatchFor %in% c("X", "XX"))) %>%
  mutate(
    GoalsInMatchFor = str_split(GoalsInMatchFor, ",\\s*")
  ) %>%
  unnest(GoalsInMatchFor) %>%
  mutate(
    GoalsInMatchFor = str_trim(GoalsInMatchFor),
    StringLength = nchar(GoalsInMatchFor)
  ) %>%
  filter(StringLength == 10) %>%
  group_by(SeasonMatchNumber, TeamID) %>%
  mutate(
    GoalCount = row_number(),
    Scorer = str_sub(GoalsInMatchFor, 1, 2),
    Assistor = str_sub(GoalsInMatchFor, 3, 4),
    Half = as.numeric(str_sub(GoalsInMatchFor, 5, 5)),
    MinuteShown = as.numeric(str_sub(GoalsInMatchFor, 6, 8)),
    Second = as.numeric(str_sub(GoalsInMatchFor, 9, 10))
  ) %>%
  ungroup() %>%
  mutate(
    TotalSecondsElapsed = case_when(
      Half == 1 ~ (MinuteShown * 60) + Second,
      Half == 2 ~ FirstHalfSecs + ((MinuteShown - 45) * 60) + Second,
      TRUE ~ NA_real_
    )
  ) %>%
  filter(Scorer != "OG") %>%
  select(SeasonMatchNumber, TeamID, GoalCount, Scorer, Assistor, TotalSecondsElapsed)

# Step 4: Player goal/assist table
player_goal_events <- goals_exploded %>%
  pivot_longer(cols = c(Scorer, Assistor), names_to = "Role", values_to = "Player") %>%
  filter(Player != "XX", Player != "") %>%
  group_by(SeasonMatchNumber, TeamID, Player) %>%
  summarise(
    FirstScoringTime = min(TotalSecondsElapsed[Role == "Scorer"], na.rm = TRUE),
    FirstAssistingTime = min(TotalSecondsElapsed[Role == "Assistor"], na.rm = TRUE),
    NumGoals = sum(Role == "Scorer"),
    NumAssists = sum(Role == "Assistor"),
    .groups = "drop"
  ) %>%
  mutate(
    FirstScoringTime = ifelse(is.infinite(FirstScoringTime), NA, FirstScoringTime),
    FirstAssistingTime = ifelse(is.infinite(FirstAssistingTime), NA, FirstAssistingTime),
    FirstGoalOrAssistTime = pmin(FirstScoringTime, FirstAssistingTime, na.rm = TRUE),
    Scored = if_else(!is.na(FirstScoringTime), 1, 0),
    Assisted = if_else(!is.na(FirstAssistingTime), 1, 0),
    ScoredOrAssisted = if_else(!is.na(FirstGoalOrAssistTime), 1, 0)
  )

# Step 5: Player-match level table
player_match_with_goals <- match_player_entries %>%
  left_join(player_goal_events, by = c("SeasonMatchNumber", "TeamID", "Player")) %>%
  mutate(PlayerID = Player) %>%
  mutate(MatchHadGoalOrAssist = if_else(is.na(ScoredOrAssisted), 0, ScoredOrAssisted))

player_match_with_goals <- player_match_with_goals %>%
  left_join(
    Matches_final %>%
      select(SeasonMatchNumber, TeamID, TotalMatchSeconds),
    by = c("SeasonMatchNumber", "TeamID")
  ) %>%
  mutate(PercentGoalTime = FirstScoringTime / TotalMatchSeconds)

# Step 6: Touches preparation
Exclude_Touch_Player <- c("TA", "CO", "NEG")
Exclude_Situation_Player <- c("GF", "GA", "SUB")

Touches_PlayerHyp <- Touches_final %>%
  filter(!(HapticRitual %in% Exclude_Touch_Player)) %>%
  filter(!(Situation %in% Exclude_Situation_Player)) %>%
  mutate(TeamID = Team) %>%
  left_join(
    Matches_final %>%
      mutate(TeamID = str_sub(MatchID, 1, 2)) %>%
      select(SeasonMatchNumber, TeamID, FirstHalfLength),
    by = c("SeasonMatchNumber", "TeamID")
  ) %>%
  mutate(
    FirstHalfLength = as.numeric(FirstHalfLength),
    FirstHalfSeconds = convert_mmss_to_seconds(FirstHalfLength),
    Half = as.numeric(str_sub(Time, 1, 1)),
    MinuteShown = as.numeric(str_sub(Time, 2, 4)),
    SecondShown = as.numeric(str_sub(Time, 5, 6)),
    TimeInSeconds = case_when(
      Half == 1 ~ (MinuteShown * 60) + SecondShown,
      Half == 2 ~ FirstHalfSeconds + ((MinuteShown - 45) * 60) + SecondShown,
      TRUE ~ NA_real_
    )
  )


#############
# Section B: Look at how touch counts change throughout a match
#############

# Looking at total touches across the entire season and all teams and players

# Plot: Histogram of touches by match time in 1-min bins
# Doesn't show much because games last longer than others
Histogram_TouchesTime <- ggplot(Touches_PlayerHyp, aes(x = TimeInSeconds / 60)) +  # convert seconds to minutes
  geom_histogram(binwidth = 1, fill = "steelblue", color = "black") +  # 1-minute bins
  labs(title = "Touches by Match Time (5-Minute Bins)",
       x = "Match Time (minutes)",
       y = "Number of Touches") +
  theme_minimal()

# Adds total match length in seconds and mutates it to have a Percent completion token
Touches_PlayerHyp <- Touches_PlayerHyp %>%
  left_join(
    Matches_final %>%
      mutate(TeamID = str_sub(MatchID, 1, 2),
             MatchLength_Minutes = floor(as.numeric(MatchLength) / 100),
             MatchLength_Seconds = as.numeric(MatchLength) %% 100,
             TotalMatchSeconds = (MatchLength_Minutes * 60) + MatchLength_Seconds) %>%
      select(SeasonMatchNumber, TeamID, TotalMatchSeconds),
    by = c("SeasonMatchNumber", "TeamID")
  ) %>%
  mutate(PercentOfMatch = TimeInSeconds / TotalMatchSeconds)

# Step 1: Bin data into 1% bins
Touches_PlayerHyp_binned <- Touches_PlayerHyp %>%
  mutate(PercentBin = floor(PercentOfMatch / 0.01) * 0.01) %>%  # bins of 1%
  group_by(PercentBin) %>%
  summarise(TouchCount = n(), .groups = "drop")

# Plot: Histogram with percent of match completion (1% bin)
Histogram_TouchesTime_PercentTime <- ggplot(Touches_PlayerHyp_binned, aes(x = PercentBin, y = TouchCount)) +
  geom_col(fill = "steelblue", color = "black", width = 0.01) +
  labs(title = "Touches by % of Match Completion",
       x = "% of Match Completion",
       y = "Number of Touches") +
  theme_minimal()

# Plot histogram + smooth trend line (LOESS)
histogram_smoothline <- ggplot(Touches_PlayerHyp_binned, aes(x = PercentBin, y = TouchCount)) +
  geom_col(fill = "steelblue", color = "black", width = 0.01) +  # Histogram bars
  geom_smooth(method = "loess", se = FALSE, color = "red", size = 1.2, span = 0.3) +  # Smooth line
  labs(title = "Touches by % of Match Completion (Smoothed via LOESS)",
       x = "% of Match Completion",
       y = "Number of Touches") +
  theme_minimal()

```

```{r Histogram_TouchesTime, echo=FALSE, fig.height=4, fig.width=8}
Histogram_TouchesTime
```

While this raw histogram by clock minutes gives a general impression, it does not normalize for variable match lengths.


### Final Figure: Smoothed Touch Distribution Across Time
```{r histogram_smoothline, echo=FALSE, fig.height=5, fig.width=9}
histogram_smoothline
```

This normalized histogram shows how touches distribute across matches regardless of game length. 

The final visualization bins touches by **1% intervals** of match progress and overlays a **LOESS-smoothed trendline**. We observe:

- A sharp rise in touch behavior early in the match
- A relatively stable mid-game baseline
- A late-match uptick, possibly linked to urgency or team-level coordination needs

This pattern may reflect the evolution of interpersonal dynamics and game tempo. Future analyses may compare this with goal distribution, player fatigue markers, or team-specific variations.

# *8. Inter-rater Reliability*

This section evaluates inter-rater reliability (IRR) across 12 shared matches using multiple perspectives:
- Total counts of touches
- Counts of reciprocal and non-reciprocal touches
- Intraclass correlation coefficients (ICC)

```{r InterRaterReliability, message=FALSE, warning=FALSE}

library(tidyverse)
library(data.table)
library(broom)
library(janitor)
library(readxl)
library(rmarkdown)
library(readr)
library(dplyr)
library(irr)
library(fuzzyjoin)
library(knitr)

# Situations excluded from core analysis for these hypotheses: Goals For/Against, Substitutions
Exclude_Touch <- c("TA", "CO", "NEG")
Exclude_Situation <- c("GF", "GA", "SUB")

Interrater <- Touches_interrater %>%  #duplicate and filter
  filter(!(HapticRitual %in% Exclude_Touch)) %>%
  filter(!(Situation %in% Exclude_Situation))

############################ Simple Frequency Check ############################

#Count check per match (simply how many each rater saw)

touch_counts <- Interrater %>%
  group_by(SeasonMatchNumber, Rater) %>%
  summarise(TouchCount = n(), .groups = "drop")

# Plot frequency per match per rater
freq_per_match_perrater_plot <- ggplot(touch_counts, aes(x = factor(SeasonMatchNumber), y = TouchCount, fill = Rater)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Touch Count per Match by Rater",
       x = "Season Match Number",
       y = "Touch Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

###ICC - Intraclass Correlation Coefficient - Interval data:

# reshape your data: rows = matches, columns = raters
icc_data <- Interrater %>%
  group_by(SeasonMatchNumber, Rater) %>%
  summarise(Count = n(), .groups = "drop") %>%
  pivot_wider(names_from = Rater, values_from = Count)

# Apply ICC (two-way random effects model)
icc_result <- icc(icc_data[,-1], model = "twoway", type = "agreement", unit = "single")


############################ Simple Reciprocity Check ############################


Reciprocal_IR <- Touches_interrater %>%
  filter(!(HapticRitual %in% Exclude_Touch)) %>%
  filter(!(Situation %in% Exclude_Situation)) %>%
  mutate(
    Reciprocity = str_trim(Reciprocal),
    ReciprocityType = case_when(
      Reciprocity %in% c("Y", "G") ~ "Reciprocal",
      Reciprocity == "N" ~ "NonReciprocal",
      TRUE ~ NA_character_
    )
  ) %>%
  filter(!is.na(ReciprocityType))

#Count how many touches each rater coded as reciprocal vs non-reciprocal 
Recip_Counts <- Reciprocal_IR %>%
  group_by(SeasonMatchNumber, Rater, ReciprocityType) %>%
  summarise(Count = n(), .groups = "drop") %>%
  pivot_wider(names_from = ReciprocityType, values_from = Count, values_fill = 0)


#Group by match and rater
Recip_Counts <- Reciprocal_IR %>%
  group_by(SeasonMatchNumber, Rater, ReciprocityType) %>%
  summarise(Count = n(), .groups = "drop") %>%
  pivot_wider(names_from = ReciprocityType, values_from = Count, values_fill = 0)

icc_data_recip <- Recip_Counts %>%
  select(SeasonMatchNumber, Rater, Reciprocal) %>%
  pivot_wider(names_from = Rater, values_from = Reciprocal)

icc_result_recip <- icc(icc_data_recip[,-1], model = "twoway", type = "agreement", unit = "single")


icc_data_nonrecip <- Recip_Counts %>%
  select(SeasonMatchNumber, Rater, NonReciprocal) %>%
  pivot_wider(names_from = Rater, values_from = NonReciprocal)

icc_result_nonrecip <- icc(icc_data_nonrecip[,-1], model = "twoway", type = "agreement", unit = "single")

#Make some charts

# Filter for reciprocal touches
recip_counts_plot <- Reciprocal_IR %>%
  filter(ReciprocityType == "Reciprocal") %>%
  group_by(SeasonMatchNumber, Rater) %>%
  summarise(Count = n(), .groups = "drop")

# Plot
reciprocal_touch_count_per_rater <- ggplot(recip_counts_plot, aes(x = factor(SeasonMatchNumber), y = Count, fill = Rater)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Reciprocal Touch Count per Match by Rater",
    x = "Season Match Number",
    y = "Reciprocal Touch Count"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Filter for non-reciprocal touches
nonrecip_counts_plot <- Reciprocal_IR %>%
  filter(ReciprocityType == "NonReciprocal") %>%
  group_by(SeasonMatchNumber, Rater) %>%
  summarise(Count = n(), .groups = "drop")

# Plot
nonreciprocal_touch_count_per_rater <- ggplot(nonrecip_counts_plot, aes(x = factor(SeasonMatchNumber), y = Count, fill = Rater)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Non-Reciprocal Touch Count per Match by Rater",
    x = "Season Match Number",
    y = "Non-Reciprocal Touch Count"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


##########Global
# Total: Keep everything except TA, CO, NEG (but DO allow "IT")
Interrater_Total <- Touches_interrater %>%
  filter(!(HapticRitual %in% Exclude_Touch)) %>%
  filter(!(Situation %in% Exclude_Situation)) %>%
  group_by(Rater) %>%
  summarise(Count = n(), .groups = "drop") %>%
  mutate(TouchType = "Total")

# Recip / NonRecip: Apply stricter filter (exclude IT)
Interrater_RecipFiltered <- Touches_interrater %>%
  filter(!(HapticRitual %in% Exclude_Touch)) %>%
  filter(!(Situation %in% Exclude_Situation)) %>%
  mutate(
    Reciprocity = str_trim(Reciprocal),
    TouchType = case_when(
      Reciprocity %in% c("Y", "G") ~ "Reciprocal",
      Reciprocity == "N" ~ "NonReciprocal",
      TRUE ~ NA_character_
    )
  ) %>%
  filter(!is.na(TouchType))

Interrater_Specific <- Interrater_RecipFiltered %>%
  group_by(Rater, TouchType) %>%
  summarise(Count = n(), .groups = "drop")

# Combine all
Global_Touch_Summary <- bind_rows(Interrater_Total, Interrater_Specific) %>%
  mutate(TouchType = factor(TouchType, levels = c("Total", "Reciprocal", "NonReciprocal")))

Global_Touch_Summary_plot <- ggplot(Global_Touch_Summary, aes(x = TouchType, y = Count, fill = Rater)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Global Comparison of Touch Counts by Rater (Filtered Reciprocities Only)",
    x = "Touch Type",
    y = "Total Count",
    fill = "Rater"
  ) +
  theme_minimal()

##ICC Table

# Build total count per match/rater
icc_data_total <- Touches_interrater %>%
  filter(!(HapticRitual %in% Exclude_Touch)) %>%
  filter(!(Situation %in% Exclude_Situation)) %>%  # NOTE: only GF, GA, SUB excluded (not IT)
  group_by(SeasonMatchNumber, Rater) %>%
  summarise(Count = n(), .groups = "drop") %>%
  pivot_wider(names_from = Rater, values_from = Count)

# Already done earlier:
icc_result_total <- icc(icc_data_total[,-1], model = "twoway", type = "agreement", unit = "single")
icc_result_recip <- icc(icc_data_recip[,-1], model = "twoway", type = "agreement", unit = "single")
icc_result_nonrecip <- icc(icc_data_nonrecip[,-1], model = "twoway", type = "agreement", unit = "single")

# Extract results into a data frame
icc_summary <- tibble(
  TouchType = c("Total", "Reciprocal", "NonReciprocal"),
  ICC = c(icc_result_total$value, icc_result_recip$value, icc_result_nonrecip$value),
  Lower_CI = c(icc_result_total$lbound, icc_result_recip$lbound, icc_result_nonrecip$lbound),
  Upper_CI = c(icc_result_total$ubound, icc_result_recip$ubound, icc_result_nonrecip$ubound)
)

library(knitr)
library(kableExtra)

icc_summary %>%
  mutate(across(where(is.numeric), round, 3)) %>%
  kable(caption = "ICC Values by Touch Type", align = "c") %>%
  kable_styling(full_width = FALSE)
```

## Touch counts by rater and match

We first examine the total touch counts coded by each rater per match to check for discrepancies.

```{r IRR1, echo=FALSE, message=FALSE, warning=FALSE}
freq_per_match_perrater_plot

icc_result
```

# Reciprocity check

Reciprocal

```{r IRR2, echo=FALSE, message=FALSE, warning=FALSE}
reciprocal_touch_count_per_rater
icc_result_recip

```

Non-Reciprocal 
```{r IRR3, echo=FALSE, message=FALSE, warning=FALSE}
nonreciprocal_touch_count_per_rater
icc_result_nonrecip
```

Global IRR

```{r IRR4, echo=FALSE, message=FALSE, warning=FALSE}

Global_Touch_Summary_plot
icc_summary
```


