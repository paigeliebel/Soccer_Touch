---
title: "PhaseOne_Liebel"
author: "Paige Liebel"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Phase One

Data Management, merging, and cleaning not shown. 
```{r Data Management, include=FALSE}
# Data_Management
# For more information on these data frames please look at the README.md file

library(tidyverse)
library(data.table)
library(broom)
library(janitor)
library(readxl)
library(rmarkdown)
library(readr)

################################################################

# raters and corresponding sheets
# Rater1 = Paige, Rater2 = Tobi, Rater3 = Simon

raters <- list(
  Rater1 = list(touch = "Touch_Paige.csv", match = "Match_Paige.csv"),
  Rater2 = list(touch = "Touch_Tobi.csv",  match = "Match_Tobi.csv"),
  Rater3 = list(touch = "Touch_Simon.csv", match = "Match_Simon.csv")  
)

Touch_Dataframes_List <- map2(names(raters), raters, function(rater_name, files) {
  read_csv(file.path("SpreadSheets", files$touch)) %>%
    slice(-1) %>%  # remove instruction row
    mutate(across(where(is.character), ~ str_replace_all(., '^"|"$', ""))) %>%
    mutate(Rater = rater_name)
})

Touches <- bind_rows(Touch_Dataframes_List)

Match_Dataframes_List <- map2(names(raters), raters, function(rater_name, files) {
  read_csv(file.path("SpreadSheets", files$match)) %>%
    slice(-1) %>%  # removes instruction row (row 2 from the sheet)
    mutate(across(where(is.character), ~ str_replace_all(., '^"|"$', ""))) %>%
    mutate(Rater = rater_name)
})

Matches <- bind_rows(Match_Dataframes_List)


############################ Additional Data for Comparing ############################ 

#Primary_SeasonOverview <- read_csv("SpreadSheets/Primary_SeasonOverview.csv")

Team_IDs <- read_csv("SpreadSheets/TeamIDs.csv")

#Stadiums <- read_csv("SpreadSheets/Stadiums.csv")

#MatchAssignments_WatchOrder <- read_csv("SpreadSheets/MatchAssignments_WatchOrder.csv")

StandingsByWeek <- read_csv("SpreadSheets/StandingsByWeek_Clean.csv")

FinalStandings <- read_csv("SpreadSheets/FinalSeasonStandings.csv")

############################ Defining Valid Entries ############################ 

#Defining valid entries into columns based on project setup

# Define valid values

valid_touch_actions <- c(
  "Tap", "Bump", "Push", "Squeeze", "Grab",
  "Kiss", "Hug", "Rub", "Stroke"
)

valid_reciprocal <- c("N", "Y", "G")

valid_body_parts <- c(
  "H", "Arm", "FT", "Legs", "BT", "Gluteal Region", 
  "Head", "Neck", "Feet"
)

valid_situations <- c(
  "F", "FY", "FR", "KS", "SA", "PP", "SUB", "GF", "GA", "DA",
  "CK", "TI", "REF", "IT", "HB", "OFF", "GK", "HUD", "WALL",
  "PEN", "Other", "BRAWL"
)

valid_hapticrituals <- c(
  "HF1", "HF2", "LF1", "LF2", "CO", "HS", "HT", "P", "CB",
  "GHUG", "FB", "HR", "HH", "CR", "DP", "BS", "HUP", "CAP",
  "SG", "NEG", "Other", "FBP", "BBP", "HUG", "CHUG", "TA", "SHUG"
)

############################ Cleaning Data | Obvious Human Error ############################ 

#Cleaning Functions to fix user input error: Such as "Arn" to "Arm"

clean_touch_action <- function(x) {
  case_when(
    x %in% c("GHUG", "HUG") ~ "Hug",
    TRUE ~ x
  )
}

clean_reciprocal <- function(x) {
  case_when(
    x == "B" ~ "N",
    TRUE ~ x
  )
}

clean_body_parts <- function(x) {
  x %>%
    as.character() %>%
    str_remove_all('^\"|\"$') %>%           # remove any surrounding quotes
    str_split(",\\s*") %>%
    map_chr(~ paste(
      str_trim(str_replace_all(.x, c(
        "Arn" = "Arm",
        "AH" = "Arm",
        "Hand" = "H",
        "Foot" = "Feet",
        "Back Torso" = "BT",
        "Front Torso" = "FT",
        "\\bLeg\\b" = "Legs",
        "Bt" = "BT",
        "Ft" = "FT"
      ))),
      collapse = ", "
    ))
}

clean_situation <- function(x) {
  case_when(
    x == "FEF" ~ "REF",
    x == "HK" ~ "GK",
    x == "PK" ~ "PEN",
    x == "Ref" ~ "REF",
    TRUE ~ x
  )
}

clean_haptic_ritual <- function(x) {
  x %>%
    as.character() %>%
    str_remove_all('^\"|\"$') %>%
    str_split(",\\s*") %>%
    map_chr(~ paste(
      str_trim(str_replace_all(.x, c(
        "LF!" = "LF1"
      ))),
      collapse = ", "
    ))
}

clean_visibility <- function(x) {
  case_when(
    x %in% c("B", "H") ~ "G",
    TRUE ~ x
  )
}


#Now applying these functions to corresponding data frames and columns

Touches <- Touches %>%
  mutate(
    TouchAction = clean_touch_action(TouchAction),
    ToucherBodyPart = clean_body_parts(ToucherBodyPart),
    ToucheeBodyPart = clean_body_parts(ToucheeBodyPart),
    Situation = clean_situation(Situation),
    HapticRitual = clean_haptic_ritual(HapticRitual),
    Reciprocal = clean_reciprocal(Reciprocal),
    Visibility = clean_visibility(Visibility)
  )

############################ Functions to check for invalid entries in data frame ############################ 

#First fxns for checking columns that had lists (read in strangely so needed extra love)

is_invalid_bodypart <- function(x) { #splits lists within cell to look at individual values (checks to make sure "FT, Arn" is flagged for "Arn")
  x %>%
    as.character() %>%                    # ensures all input is character
    str_split(",\\s*") %>%
    map_lgl(~ {
      parts <- .x
      if (any(is.na(parts)) || any(parts == "NA")) return(TRUE)  # flag both empty and NA values
      any(!parts %in% valid_body_parts)     # TRUE only if any part is invalid
    })
}

is_invalid_haptic_ritual <- function(x) { #splits lists within cell to look at individual values (flags things like "CR, BF" for "BF" which is not a valid haptic ritual)
  x %>%
    as.character() %>%
    str_split(",\\s*") %>%
    map_lgl(~ {
      parts <- .x
      if (any(is.na(parts)) || any(parts == "NA")) return(TRUE)
      any(!parts %in% valid_hapticrituals)
    })
}

#Function to let us know where the invalid feature occurs. Output is a new column that contains the column location of the error
get_invalid_fields <- function(row) {
  invalid_fields <- c()
  
  if (!(row$Reciprocal %in% valid_reciprocal)) {
    invalid_fields <- c(invalid_fields, "Reciprocal")
  }
  
  if (is_invalid_bodypart(row$ToucherBodyPart)) {
    invalid_fields <- c(invalid_fields, "ToucherBodyPart")
  }
  
  if (is_invalid_bodypart(row$ToucheeBodyPart)) {
    invalid_fields <- c(invalid_fields, "ToucheeBodyPart")
  }
  
  if (!(row$Situation %in% valid_situations)) {
    invalid_fields <- c(invalid_fields, "Situation")
  }
  
  if (is_invalid_haptic_ritual(row$HapticRitual)) {
    invalid_fields <- c(invalid_fields, "HapticRitual")
  }
  
  if (!(row$TouchAction %in% valid_touch_actions)) {
    invalid_fields <- c(invalid_fields, "TouchAction")
  }
  
  paste(invalid_fields, collapse = ", ")
}
############################ Trouble-Shooting | Human Input Error ############################ 

#Troubleshooting: Looking at each column and checking values to look for human error while inputting data during collection

cols <- c("Team", "TouchAction", "Reciprocal", "ToucherBodyPart", "ToucheeBodyPart", "Situation", "HapticRitual", "Visibility")

#Starting with Touches

unique_vals <- Touches %>%
  select(all_of(cols)) %>% 
  map(~ unique(.))

max_len <- max(lengths(unique_vals))
padded <- map(unique_vals, ~ { length(.) <- max_len; . })
unique_values_df <- as.data.frame(padded)

#determining which touchID and rater discrepancies are connected to
#"Show me the mistakes, so I can fix them or track who made them":

Touches_invalid <- Touches %>%
  filter(
    !(Reciprocal %in% valid_reciprocal) |
      is_invalid_bodypart(ToucherBodyPart) |
      is_invalid_bodypart(ToucheeBodyPart) |
      !(Situation %in% valid_situations) |
      is_invalid_haptic_ritual(HapticRitual) |
      !(TouchAction %in% valid_touch_actions)
  )

Touches_invalid_by_rater <- split(Touches_invalid, Touches_invalid$Rater) #split by rater

Touches_invalid_labeled <- map(Touches_invalid_by_rater, function(df) { #apply get_invalid_fields() to each row in each rater's dataframe
  df %>%
    rowwise() %>%
    mutate(Invalid_Fields = get_invalid_fields(pick(everything()))) %>%
    ungroup()
})

Touches_invalid_rater1 <- Touches_invalid_labeled[["Rater1"]]
Touches_invalid_rater2 <- Touches_invalid_labeled[["Rater2"]]
Touches_invalid_rater3 <- Touches_invalid_labeled[["Rater3"]]

############################ Final Data Frame Creation | Separation of Inter-rater Game Data ############################ 

#Creating the final data frames used for analysis
#Removes the data from matches not assigned to that specific rater. For example, if Rater 1 was assigned match 126, 
#then Rater 2 and 3 also watched it and have populated data for that match.
#this section removes that data created from rater 2 and 3 keeping only rater 1s info.
#Do this to both the Matches and Touches Dataframs (has to happen twice)

#Define match assignments
InterRaterMatches_Rater1 <- c("127", "115", "26", "87") #Paige
InterRaterMatches_Rater2 <- c("114", "39", "163", "42") #Tobi
InterRaterMatches_Rater3 <- c("95", "150", "38", "160") #Simon

#Combine all 12 interrater matches with rater mapping
interrater_assignments <- tibble(
  SeasonMatchNumber = c(InterRaterMatches_Rater1, InterRaterMatches_Rater2, InterRaterMatches_Rater3),
  AssignedRater = c(rep("Rater1", length(InterRaterMatches_Rater1)),
                    rep("Rater2", length(InterRaterMatches_Rater2)),
                    rep("Rater3", length(InterRaterMatches_Rater3)))
)

#SeasonMatchNumber imported differently, need to change to same character thingy
interrater_assignments <- interrater_assignments %>%
  mutate(SeasonMatchNumber = as.character(SeasonMatchNumber))

Touches <- Touches %>%
  mutate(SeasonMatchNumber = str_remove(as.character(SeasonMatchNumber), "^0+")) #removes leading zeros

Matches <- Matches %>%
  mutate(SeasonMatchNumber = str_remove(as.character(SeasonMatchNumber), "^0+")) #removes leading zeros

#make new data frame from Touches, if row contains InterRaterMatches_Rater1 and the word rater 1, keep it, otherwise delete row

Touches_final <- Touches %>% #This df has all matches, but excludes the repeated matches watched for inter-rater study except by the rater they were originally assigned for
  anti_join(interrater_assignments, by = c("SeasonMatchNumber" = "SeasonMatchNumber")) %>%
  bind_rows(
    Touches %>%
      inner_join(interrater_assignments, by = c("SeasonMatchNumber")) %>%
      filter(Rater == AssignedRater)
  )

#Same as above but for matches now (performance data for each match)
Matches_final <- Matches %>%
  anti_join(interrater_assignments, by = c("SeasonMatchNumber" = "SeasonMatchNumber")) %>%
  bind_rows(
    Matches %>%
      inner_join(interrater_assignments, by = c("SeasonMatchNumber")) %>%
      filter(Rater == AssignedRater)
  )


############################ Inter-rater Game Data ############################ 

#Creation of data frames for Inter-rater data analysis
#Simply looks at all matches that were watched by multiple people

Touches_interrater <- Touches %>%
  inner_join(interrater_assignments, by = "SeasonMatchNumber")

Matches_interrater <- Matches %>%
  inner_join(interrater_assignments, by = "SeasonMatchNumber")



```

```{r}
#Cleaning up and Extracting Info from the Match_Performance Sheet
#Goal to get:
#Minutes Played for each player
#Minutes played by each team
#Penalty Kick Info

library(tidyverse)
library(data.table)
library(broom)
library(janitor)
library(readxl)
library(rmarkdown)
library(readr)
library (dplyr)
library(plotly)
library(mgcv)
library(ggplot2)
library(forcats)
library(ggridges)
library(DescTools)
library(tidyr)
library(purrr)


source("Data_Management.R") #Runs and brings in Matches_final from Data_Management.R script

############################ Overall Team Data ############################
#Info Team by Team
Matches_ID <- Matches_final %>%
  mutate(
    MatchID = str_pad(MatchID, width = 4, pad = "0"),  # in case it was shortened
    TeamID = str_sub(MatchID, 1, 2),
    Substitutes = as.character(Substitutes),
    Substitutes = str_replace_all(Substitutes, "\\.", ",")
  )

team_minutesplayed <- Matches_ID %>% 
  mutate(
    MatchLength = as.numeric(MatchLength)  # Convert to numeric
  ) %>%
  group_by(TeamID) %>%
    summarise(
      TotalMinutesPlayed = sum(MatchLength, na.rm = TRUE),
      MatchCount = n()
    ) %>%
    arrange(desc(TotalMinutesPlayed))

#Formations teams played
formation_counts <- Matches_ID %>%
  group_by(TeamID, Formation) %>%
  summarise(FormationCount = n(), .groups = "drop") %>%
  pivot_wider(
    names_from = Formation,
    values_from = FormationCount,
    values_fill = 0  # Fill in 0 if a team never used a certain formation
  )

############################ Overall League Data ############################

#Most Popular Formations
popular_formations <- Matches_ID %>%
  group_by(Formation) %>%
  summarise(TimesUsed = n(), .groups = "drop") %>%
  arrange(desc(TimesUsed))

############################ Player Data ############################

#Determine how many minutes each player played

#First determine the starters across the season for each team
starter_players <- Matches_ID %>%
  mutate(StarterList = str_split(Starters, ",\\s*")) %>%   # split by comma, trim spaces
  rowwise() %>%
  mutate(
    StarterCount = length(StarterList),
    StarterFlag = ifelse(StarterCount != 11, TRUE, FALSE)  # flag if not 11
  ) %>%
  ungroup() %>%
  select(TeamID, StarterList, StarterFlag, SeasonMatchNumber, FirstHalfLength, SecondHalfLength) %>%
  unnest(StarterList) %>%
  mutate(StarterList = str_trim(StarterList))  # clean whitespace

unique_team_players <- starter_players %>%
  mutate(StarterList = str_trim(StarterList)) %>%
  distinct(TeamID, StarterList) %>%
  rename(Player = StarterList)

flagged_starter_matches <- Matches_ID %>%
  mutate(
    StarterList = str_split(Starters, ",\\s*"),
    StarterCount = lengths(StarterList)
  ) %>%
  filter(StarterCount != 11) %>%
  select(SeasonMatchNumber, FirstHalfLength, SecondHalfLength, TeamID, StarterCount, Starters)

#Determine the Subs and add them to the starters
subs_exploded <- Matches_ID %>%
  select(SeasonMatchNumber, FirstHalfLength, SecondHalfLength, TeamID, Substitutes) %>%
  filter(!is.na(Substitutes) & Substitutes != "") %>%
  mutate(Substitutes = as.character(Substitutes)) %>% 
  mutate(
    Substitutes = str_split(Substitutes, ",\\s*")) %>%
  unnest(Substitutes)

#Parse the substitution strings into their parts
subs_parsed_noRedCards <- subs_exploded %>%
  filter(str_detect(Substitutes, "^\\d{8}$")) %>%  # Keep only well-formed subs
  mutate(
    SubIn   = str_sub(Substitutes, 1, 2),
    SubOut  = str_sub(Substitutes, 3, 4),
    Half    = str_sub(Substitutes, 5, 5),
    Minute  = as.numeric(str_sub(Substitutes, 6, 8))
  ) %>%
  select(SeasonMatchNumber, FirstHalfLength, SecondHalfLength, TeamID, Substitutes, SubIn, SubOut, Half, Minute)

# Parse red card "subs"
red_cards_parsed <- subs_exploded %>%
  filter(str_detect(Substitutes, "^FR\\d{6}$")) %>%
  mutate(
    SubIn   = NA_character_,  # no one comes in because of Red Card
    SubOut  = str_sub(Substitutes, 3, 4),  # player sent off
    Half    = str_sub(Substitutes, 5, 5),
    Minute  = as.numeric(str_sub(Substitutes, 6, 8))
  ) %>%
  select(SeasonMatchNumber, FirstHalfLength, SecondHalfLength, TeamID, Substitutes, SubIn, SubOut, Half, Minute)

subs_parsed <- bind_rows(subs_parsed_noRedCards, red_cards_parsed) #combines together acceptable values

#Sub issues to flag
sub_issues <- Matches_ID %>%
  mutate(SeasonMatchNumber = as.character(SeasonMatchNumber)) %>%
  separate_rows(Substitutes, sep = ",\\s*") %>%
  filter(Substitutes != "") %>%
  mutate(Flag = !str_detect(Substitutes, "^\\d{8}$") & !str_detect(Substitutes, "^FR\\d{6}$")) %>% #selects subs with 8 digits and those with improper FR setup
  filter(Flag) %>%
  select(SeasonMatchNumber, Substitutes)

# Now filter out bad sub entries (those not 8 digits or not FR + 6 digits)
subs_parsed_clean <- subs_parsed %>%
  anti_join(sub_issues, by = c("SeasonMatchNumber", "Substitutes"))

# Get all distinct subbed-in players per team
subbed_in_players <- subs_parsed_clean %>%
  select(TeamID, SubIn) %>%
  distinct() %>%
  rename(Player = SubIn)

unique_sub_players <- subs_parsed_clean %>%
  mutate(SubIn = str_trim(SubIn)) %>%                 # <- trim here too
  distinct(TeamID, SubIn) %>%
  rename(Player = SubIn)

# Combine starters and subbed-in players
all_unique_team_players <- bind_rows(unique_team_players, unique_sub_players) %>%
  mutate(
    Player = str_trim(Player),
    PlayerCharLength = nchar(Player)
  ) %>%
  distinct(TeamID, Player, PlayerCharLength)

#Give a complete list of each jersey number that shows up for a team
# Group players by team and nest them into a list column
team_player_lists <- all_unique_team_players %>%
  mutate(Player = as.character(str_trim(Player))) %>%  # Clean and ensure characters
  group_by(TeamID) %>%
  summarise(
    PlayerList = paste(sort(unique(Player)), collapse = ", "),
    .groups = "drop"
  )

#Now Let's figure out minutes played for starters who were not subbed out in a match

# From starter_players: select and rename StarterList to Player
starter_players_long <- starter_players %>%
  select(SeasonMatchNumber, TeamID, StarterList) %>%
  rename(Player = StarterList)

# From subs_parsed_clean: select and rename SubIn to Player
subins_long <- subs_parsed_clean %>%
  select(SeasonMatchNumber, TeamID, SubIn) %>%
  rename(Player = SubIn)

# Combine both into one dataframe, keep distinct values
match_player_entries <- bind_rows(starter_players_long, subins_long) %>%
  mutate(Player = str_trim(as.character(Player))) %>%
  distinct(SeasonMatchNumber, TeamID, Player, .keep_all = TRUE)

#pure iteration row by row (inefficient) to see fi player was subbed in/out
match_player_entries <- match_player_entries %>% 
  mutate(
    WasPlayerSubbedIn = pmap_chr(
      list(SeasonMatchNumber, TeamID, Player),
      ~ if_else(
        any(subs_parsed_clean$SeasonMatchNumber == ..1 &
              subs_parsed_clean$TeamID == ..2 &
              subs_parsed_clean$SubIn == ..3),
        "Y", "N"
      )
    )
  )

match_player_entries <- match_player_entries %>%
  mutate(
    WasPlayerSubbedOut = pmap_chr(
      list(SeasonMatchNumber, TeamID, Player),
      ~ if_else(
        any(subs_parsed_clean$SeasonMatchNumber == ..1 &
              subs_parsed_clean$TeamID == ..2 &
              subs_parsed_clean$SubOut == ..3),
        "Y", "N"
      )
    )
  )

Matches_ID_unique <- Matches_ID %>%
  mutate(SeasonMatchNumber = as.character(SeasonMatchNumber)) %>%
  select(SeasonMatchNumber, TeamID, FirstHalfLength, SecondHalfLength) %>%
  distinct()

Matches_ID_unique %>%
  count(SeasonMatchNumber, TeamID) %>%
  filter(n > 1)  # should not happen

Matches_ID_unique <- Matches_ID_unique %>% distinct(SeasonMatchNumber, TeamID, .keep_all = TRUE)

# Now join safely by both SeasonMatchNumber and TeamID
match_player_entries <- match_player_entries %>%
  mutate(SeasonMatchNumber = as.character(SeasonMatchNumber)) %>%
  left_join(Matches_ID_unique, by = c("SeasonMatchNumber", "TeamID"))

# First, extract only relevant sub-in/out info
sub_in_info <- subs_parsed_clean %>%
  filter(!is.na(SubIn)) %>%  # red cards won't have SubIn
  select(SeasonMatchNumber, TeamID, Player = SubIn, SubbedInHalf = Half, SubbedInMinute = Minute)
  
sub_out_info <- subs_parsed_clean %>%
  select(SeasonMatchNumber, TeamID, Player = SubOut, SubbedOutHalf = Half, SubbedOutMinute = Minute)
  
sub_in_info %>%
  count(SeasonMatchNumber, TeamID, Player) %>%
  filter(n > 1)  # should all be 1

sub_out_info %>%
  count(SeasonMatchNumber, TeamID, Player) %>%
  filter(n > 1)  # same

# Now, join it to match_player_metrics for only those who were subbed in/out
match_player_entries <- match_player_entries %>%
  left_join(sub_in_info, by = c("SeasonMatchNumber", "TeamID", "Player"))

match_player_entries <- match_player_entries %>%
  left_join(sub_out_info, by = c("SeasonMatchNumber", "TeamID", "Player"))

match_player_entries <- match_player_entries %>%
  mutate(
    Player = str_trim(as.character(Player)),
    TeamID = str_trim(as.character(TeamID)),
    SeasonMatchNumber = str_trim(as.character(SeasonMatchNumber))
  )

#create a function to turn everything into seconds
convert_mmss_to_seconds <- function(mmss) {
  mm <- floor(mmss / 100)
  ss <- mmss %% 100
  mm * 60 + ss
}

#Convert everything to numeric
match_player_entries <- match_player_entries %>%
  mutate(
    FirstHalfLength = as.numeric(FirstHalfLength),
    SecondHalfLength = as.numeric(SecondHalfLength),
    SubbedInMinute = as.numeric(SubbedInMinute),
    SubbedOutMinute = as.numeric(SubbedOutMinute)
  )

# Apply to your data frame
match_player_entries <- match_player_entries %>%
  mutate(
    FirstHalfSeconds = convert_mmss_to_seconds(FirstHalfLength),
    SecondHalfSeconds = convert_mmss_to_seconds(SecondHalfLength)
  )

#Let's do math to figure out how many seconds each player played
match_player_entries <- match_player_entries %>%
  mutate(
    SubInOutConflict = if_else(
      WasPlayerSubbedIn == "Y" & WasPlayerSubbedOut == "Y",
      TRUE, FALSE
    )
  ) %>% 
  mutate(
    MatchSecondsPlayed = case_when(
      # Not subbed in and not subbed out â†’ full match
      WasPlayerSubbedIn == "N" & WasPlayerSubbedOut == "N" ~ (FirstHalfSeconds + SecondHalfSeconds),
      
      # Not subbed in and subbed out in 1st half
      WasPlayerSubbedIn == "N" & WasPlayerSubbedOut == "Y" & SubbedOutHalf == "1" ~
        if_else(SubbedOutMinute == 46, FirstHalfSeconds, (SubbedOutMinute * 60)),
      
      # Not subbed in and subbed out in 2nd half
      WasPlayerSubbedIn == "N" & WasPlayerSubbedOut == "Y" & SubbedOutHalf == "2" ~
        if_else(SubbedOutMinute == 46,
                FirstHalfSeconds,
                (FirstHalfSeconds + ((SubbedOutMinute - 45)*60))),
      
      # Subbed in and subbed in 1st half
      WasPlayerSubbedIn == "Y" & WasPlayerSubbedOut == "N" & SubbedInHalf == "1" ~
        if_else(SubbedInMinute == 46, convert_mmss_to_seconds(SecondHalfLength), 
                (SecondHalfSeconds + (FirstHalfSeconds - (SubbedInMinute*60)))),
      
      # Subbed in and subbed in 2nd half
      WasPlayerSubbedIn == "Y" & WasPlayerSubbedOut == "N" & SubbedInHalf == "2" ~
        if_else(SubbedInMinute == 46, SecondHalfSeconds, 
                (SecondHalfSeconds - ((SubbedInMinute - 45)*60))),
      
      # Subbed in AND subbed out
      WasPlayerSubbedIn == "Y" & WasPlayerSubbedOut == "Y" ~
        case_when(
          SubbedInMinute == 46 ~ (SubbedOutMinute - 45) * 60,
          
          SubbedInHalf == "1" & SubbedOutHalf == "1" ~ 
            (SubbedOutMinute - SubbedInMinute) * 60,
          
          SubbedInHalf == "1" & SubbedOutHalf == "2" ~ 
            (FirstHalfSeconds - SubbedInMinute * 60) + (SubbedOutMinute - 45) * 60,
          
          SubbedInHalf == "2" & SubbedOutHalf == "2" ~ 
            (SubbedOutMinute - SubbedInMinute) * 60,
          
          TRUE ~ NA_real_
        ),
      
      # Fallback
      TRUE ~ NA_real_
    )
  )

#Add a column with Rater so we know who is having errors
match_player_entries <- match_player_entries %>%
  left_join(
    Matches_final %>%
      select(SeasonMatchNumber, Rater) %>%
      distinct(),  # <-- ensures only one row per SeasonMatchNumber-Rater pair
    by = "SeasonMatchNumber"
  )

match_player_entries <- match_player_entries %>%
  mutate(
    SubInTime = case_when(
      WasPlayerSubbedIn == "N" ~ 0,
      WasPlayerSubbedIn == "Y" & SubbedInHalf == "1" ~ SubbedInMinute * 60,
      WasPlayerSubbedIn == "Y" & SubbedInHalf == "2" ~ (FirstHalfSeconds + ((SubbedInMinute - 45) * 60)),
      TRUE ~ NA_real_
    )
  )

#Now I have seconds played. Add that up for each player over the season.
player_season_totals <- match_player_entries %>%
  group_by(TeamID, Player) %>%
  summarise(
    TotalSecondsPlayed = sum(MatchSecondsPlayed, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(TotalSecondsPlayed))


duplicates <- match_player_entries %>%
  group_by(SeasonMatchNumber, TeamID, Player) %>%
  filter(n() > 1) %>%
  arrange(SeasonMatchNumber, TeamID, Player)


checker <- match_player_entries %>%
  count(SeasonMatchNumber, TeamID, Player) %>%
  filter(n > 1) %>%
  arrange(desc(n))

```

## Summary of Data

```{r}
# Data Summary and Overview
# Gives Simple overall counts, tables, data make-up etc

library(tidyverse)
library(data.table)
library(broom)
library(janitor)
library(readxl)
library(rmarkdown)
library(readr)
library (dplyr)


############################ Complete data summary | No filtering ############################ 

#Create Tables that summarizes complete data of "Touches_final" and "Matches_final"

Touches_Summary <- Touches_final
Matches_Summary <- Matches_final

Total_Touch_Instance_count <- nrow(Touches_Summary) #count total number of touches recorded

Total_Match_Count <- n_distinct(Touches_Summary$SeasonMatchNumber) #total number of matches watched

Total_Teams <- n_distinct(Touches_Summary$Team) #teams recorded

Total_Matches_perTeam <- 26 #Matches each team played (verified below)

Summary_Table_A <- tibble(
  Variable = c("Total_Touch_Instance_count", "Total_Match_Count", "Total_Teams", "Total_Matches_perTeam"),
  Value = c(
    nrow(Touches_Summary),
    n_distinct(Touches_Summary$SeasonMatchNumber),
    n_distinct(Touches_Summary$Team),
    26  # Manually verified
  )
)

############################ FlowChart | Filtering ############################ 

# Prosocial vs Nonsocial

# Prosocial touches are defined as all haptic rituals recorded excluding: 
# Tactical Adjustments, Collisions, and Negative Touch
Exclude_Touch <- c("TA", "CO", "NEG")

#Only Prosocial Touches
Touches_ProSocial <- Touches_final %>%
  filter(!(HapticRitual %in% Exclude_Touch))

#Non-social touches table (only those in Exclude_Touch)
Touches_NonSocial <- Touches_final %>%
  filter(HapticRitual %in% Exclude_Touch)

# Count n for social and nonsocial:
social_count <- nrow(Touches_ProSocial)
nonsocial_count <- nrow(Touches_NonSocial)

cat("Number of Prosocial (Social) Touches:", social_count, "\n")
cat("Number of NonSocial Touches:", nonsocial_count, "\n")

#Excluding goal for/against, substitutions (starting with prosocial set)
Exclude_Situation <- c("GF", "GA", "SUB") 

#Only Prosocial Touches
Touches_CoreData <- Touches_ProSocial %>%
  filter(!(Situation %in% Exclude_Situation))

#Count for other GF/GA/SUB
Touches_GoalsSubs <- Touches_ProSocial %>%
  filter(Situation %in% Exclude_Situation)

# Count n for GF,GA,SUB and Run-of-play:
coredata_count <- nrow(Touches_CoreData)
GoalsSubs_count <- nrow(Touches_GoalsSubs)

#Filter out IT and look at Reciprocity
Exclude_IT <- c("IT")
Touches_ReciprocalNonRecip <- Touches_CoreData %>%
  filter(!(Situation %in% Exclude_IT))

Touches_ReciprocalNonRecip <- Touches_ReciprocalNonRecip %>% 
  mutate(
    Reciprocity = str_trim(Reciprocal) #cleans up white spaces in case
  )

#Define Reciprocity
Touches_ReciprocalNonRecip <- Touches_ReciprocalNonRecip %>%
  mutate(
    Reciprocity_Group = case_when(
      Reciprocity %in% c("Y", "G") ~ "Reciprocal",
      Reciprocity == "N" ~ "NonReciprocal",
      TRUE ~ "Other"   # just in case of other values
    )
  )

# Reciprocal touches table
Reciprocal_Touches <- Touches_ReciprocalNonRecip %>%
  filter(Reciprocity_Group == "Reciprocal")

# Nonreciprocal touches table
NonReciprocal_Touches <- Touches_ReciprocalNonRecip %>%
  filter(Reciprocity_Group == "NonReciprocal")

#Look at IT touches:
# Keep only IT touches
Touches_IT <- Touches_CoreData %>%
  filter(Situation %in% "IT") %>%   # keep only IT
  mutate(
    Reciprocity = str_trim(Reciprocal) # clean white spaces
  ) %>%
  mutate(
    Reciprocity_Group = case_when(
      Reciprocity %in% c("Y", "G") ~ "Reciprocal",
      Reciprocity == "N" ~ "NonReciprocal",
      TRUE ~ "Other"
    )
  )

# Reciprocal touches within IT
Reciprocal_IT_Touches <- Touches_IT %>%
  filter(Reciprocity_Group == "Reciprocal")

# Nonreciprocal touches within IT
NonReciprocal_IT_Touches <- Touches_IT %>%
  filter(Reciprocity_Group == "NonReciprocal")

# Counts
reciprocal_count <- nrow(Reciprocal_IT_Touches)
nonreciprocal_count <- nrow(NonReciprocal_IT_Touches)


```

